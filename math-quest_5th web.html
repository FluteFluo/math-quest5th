<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>算数クエスト ～5年生の冒険～</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 基本的なスタイルとアニメーション */
    body, html { margin: 0; padding: 0; height: 100%; font-family: sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"; background-color: #111827; }
    #root { height: 100%; }
    @keyframes ping-once { 75%, 100% { transform: scale(1.5); opacity: 0; } }
    .animate-ping-once { animation: ping-once 1s cubic-bezier(0, 0, 0.2, 1); }
    @keyframes bounce { 0%, 100% { transform: translateY(-25%); animation-timing-function: cubic-bezier(0.8, 0, 1, 1); } 50% { transform: translateY(0); animation-timing-function: cubic-bezier(0, 0, 0.2, 1); } }
    .animate-bounce { animation: bounce 1s infinite; }
    
    @keyframes item-get-pop {
        0% { transform: scale(0.3) rotate(-30deg); opacity: 0; }
        60% { transform: scale(1.1) rotate(10deg); opacity: 1; }
        80% { transform: scale(0.95) rotate(-5deg); }
        100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }
    .animate-item-get-pop {
        animation: item-get-pop 0.7s cubic-bezier(0.175, 0.885, 0.320, 1.275) both;
    }
    @keyframes shine-effect {
        0% { transform: translateX(-150%) skewX(-30deg); }
        100% { transform: translateX(150%) skewX(-30deg); }
    }
    .shine-effect::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 50%;
        height: 100%;
        background: linear-gradient(to right, rgba(255,255,255,0) 0%, rgba(255,255,255,0.6) 50%, rgba(255,255,255,0) 100%);
        animation: shine-effect 1.5s cubic-bezier(0.65, 0.05, 0.36, 1) 1s;
    }
    .active-input-field {
        box-shadow: 0 0 0 2px #3b82f6; /* Tailwind blue-500 */
        border-color: #3b82f6 !important; /* Tailwind blue-500 */
    }
    /* 分数入力/表示用スタイル */
    .fraction-input-container {
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      vertical-align: middle;
      position: relative;
      margin: 0 0.5em;
      border-radius: 0.5rem; /* rounded-lg */
      overflow: hidden; /* 子要素のinputの角丸がはみ出さないように */
    }
    .fraction-input-container::before {
        content: '';
        position: absolute;
        left: -0.25em; /* 横棒の長さ調整 */
        right: -0.25em; /* 横棒の長さ調整 */
        top: 50%;
        height: 2px;
        background-color: currentColor; /* テキスト色に合わせる */
        transform: translateY(-50%);
        z-index: 0; /* 入力フィールドの下に配置 */
    }
    .fraction-input-container > input {
        padding: 0 0.2em;
        width: 6rem; /* 幅を固定 */
        text-align: center;
        background-color: transparent; /* 背景透明 */
        position: relative;
        z-index: 1; /* 横棒の上に配置 */
        cursor: text;
        border: 1px solid #d1d5db; /* border-gray-300 */
    }
    .fraction-input-container > input:first-child {
        border-bottom: none; /* 分数横棒があるので下線不要 */
        border-top-left-radius: 0.5rem;
        border-top-right-radius: 0.5rem;
    }
    .fraction-input-container > input:last-child {
        border-top: none; /* 分数横棒があるので上線不要 */
        border-bottom-left-radius: 0.5rem;
        border-bottom-right-radius: 0.5rem;
    }

    .fraction-display {
        display: inline-flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        margin: 0 0.2em;
        vertical-align: middle;
    }
    .fraction-display > .numerator {
        border-bottom: 2px solid currentColor;
        padding: 0 0.2em;
    }
    .fraction-display > .denominator {
        padding: 0 0.2em;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel" data-presets="react">
    const { useState, useEffect, useRef } = React;

    const GAME_STATES = { MENU: 'menu', STAGE_SELECT: 'stage-select', BATTLE: 'battle', RULES: 'rules', INVENTORY: 'inventory', FORGE: 'forge' };
    const initialPlayerData = { level: 1, exp: 0, hp: 100, maxHp: 100, mp: 50, maxMp: 50, clearedStages: [], equipment: { weapon: null, armor: null, accessory: null, tool: null }, inventory: [], materials: { ironOre: 0, silverOre: 0, starFragment: 0, perfectProof: 0 }, titles: ['見習い魔法使い'], wrongProblems: [], battleStats: { totalProblems: 0, correctAnswers: 0, consecutiveCorrect: 0, hintsUsed: 0 } };

    // ヘルパー関数: 最大公約数
    const gcd = (a, b) => {
      if (a === 0) return b;
      if (b === 0) return a;
      return gcd(b, a % b);
    };

    // ヘルパー関数: 最小公倍数 (複数引数対応)
    const lcm = (...arr) => {
      if (arr.length === 0) return 1;
      let result = arr[0];
      for (let i = 1; i < arr.length; i++) {
        if (result === 0 || arr[i] === 0) return 0;
        result = Math.abs(result * arr[i]) / gcd(result, arr[i]);
      }
      return result;
    };

    // ヘルパー関数: 小数点精度を考慮した数値フォーマット
    const formatDecimal = (num) => parseFloat(num.toPrecision(14));

    // 分数表示コンポーネント
    const FractionDisplay = ({ numerator, denominator }) => {
        // 分母が0の場合はエラー表示などを考慮する
        if (denominator === 0) return <span className="text-red-500">不正な分数</span>;
        // 整数であればそのまま表示
        if (denominator === 1) return <span>{numerator}</span>;

        return (
            <span className="fraction-display text-lg">
                <span className="numerator">{numerator}</span>
                <span className="denominator">{denominator}</span>
            </span>
        );
    };

    const MathRPGApp = () => {
      const [gameState, setGameState] = useState(GAME_STATES.MENU);
      const [playerData, setPlayerData] = useState(initialPlayerData);
      const [currentStage, setCurrentStage] = useState(null);
      const [currentProblem, setCurrentProblem] = useState(null);
      const [currentProblemIndex, setCurrentProblemIndex] = useState(0);
      const [userAnswer, setUserAnswer] = useState('');
      const [fractionTop, setFractionTop] = useState('');
      const [fractionBottom, setFractionBottom] = useState('');
      const [divisionNumerator, setDivisionNumerator] = useState('');
      const [divisionDenominator, setDivisionDenominator] = useState('');
      const [activeInput, setActiveInput] = useState('answer'); // 現在アクティブな入力フィールド
      const [showHint, setShowHint] = useState(false);
      const [battleResult, setBattleResult] = useState(null);
      const [enemyHp, setEnemyHp] = useState(100);
      const [maxEnemyHp, setMaxEnemyHp] = useState(100);
      const [showExplanation, setShowExplanation] = useState(false);
      const [battleProblems, setBattleProblems] = useState([]);
      const [gameOver, setGameOver] = useState(false);
      const [battleFeedback, setBattleFeedback] = useState({ player: '', enemy: '' });
      const [itemGetNotification, setItemGetNotification] = useState(null);
      const [materialGetNotification, setMaterialGetNotification] = useState(null);
      const [levelUpNotification, setLevelUpNotification] = useState(null); // Level Up State
      const [enemyDefeated, setEnemyDefeated] = useState(false);
      const [selectedForgeItem, setSelectedForgeItem] = useState(null);
      const fileInputRef = useRef(null);

      // --- レベルアップ機能関連 ---
      const MAX_LEVEL = 99;

      const getRequiredExp = (level) => {
          if (level >= MAX_LEVEL) return Infinity; // 最大レベル以上は必要経験値を無限大に
          // 次のレベルに必要な経験値を計算
          return Math.floor(100 * Math.pow(1.15, level - 1));
      };

      const checkForLevelUp = (playerData) => {
          let newPlayerData = { ...playerData };
          let didLevelUp = false;
          const hpBefore = newPlayerData.maxHp;
          const mpBefore = newPlayerData.maxMp;

          // 最大レベル未満の場合のみループ
          while (newPlayerData.level < MAX_LEVEL) {
              const requiredExp = getRequiredExp(newPlayerData.level);
              if (newPlayerData.exp >= requiredExp) {
                  didLevelUp = true;
                  newPlayerData.exp -= requiredExp;
                  newPlayerData.level += 1;
                  
                  const hpUp = 15;
                  const mpUp = 8;
                  newPlayerData.maxHp += hpUp;
                  newPlayerData.maxMp += mpUp;

                  // HP/MPを全回復
                  newPlayerData.hp = newPlayerData.maxHp;
                  newPlayerData.mp = newPlayerData.maxMp;
              } else {
                  break;
              }
          }

          // 最大レベルに達した場合、経験値を0にリセット（カンスト）
          if (newPlayerData.level >= MAX_LEVEL) {
              newPlayerData.exp = 0;
          }
          
          if (didLevelUp) {
              setLevelUpNotification({
                  level: newPlayerData.level,
                  maxHp: newPlayerData.maxHp,
                  maxMp: newPlayerData.maxMp,
                  hpUp: newPlayerData.maxHp - hpBefore, // 複数レベルアップにも対応
                  mpUp: newPlayerData.maxMp - mpBefore, // 複数レベルアップにも対応
              });
          }
          
          return newPlayerData;
      };
      // --- レベルアップ機能ここまで ---

      const rankMultipliers = { 1: 1, 2: 1.2, 3: 1.5, 4: 2.0, 5: 3.0 };
      
      const changeGameState = (newState) => { 
        if (newState !== GAME_STATES.FORGE) { setSelectedForgeItem(null); }
        if (document.activeElement) document.activeElement.blur(); 
        setGameState(newState); 
      };

      const stages = [ 
        { id: 1, name: '森の村', topic: '整数と小数', boss: false, enemy: 'スライム', reward: 'weapon' }, 
        { id: 2, name: '比例の丘', topic: '比例', boss: false, enemy: 'ゴブリン', reward: 'armor' }, 
        { id: 3, name: 'かけ算の谷', topic: '小数のかけ算', boss: false, enemy: 'オーク', reward: 'accessory' }, 
        { id: 4, name: 'わり算の川', topic: '小数のわり算', boss: false, enemy: 'トロール', reward: 'tool' }, 
        { id: 5, name: '倍数の街', topic: '小数の倍', boss: false, enemy: 'ウィザード', reward: 'weapon' }, 
        { id: 6, name: '1学期の城', topic: '1学期のまとめ', boss: true, enemy: '算数ドラゴン', reward: 'special' }, 
        { id: 7, name: '偶数・奇数の森', topic: '偶数と奇数、倍数と約数', boss: false, enemy: 'ダークエルフ', reward: 'armor' }, 
        { id: 8, name: '分数の洞窟', topic: '分数と小数、整数の関係', boss: false, enemy: 'ミノタウロス', reward: 'accessory' }, 
        { id: 9, name: '計算の神殿', topic: '分数のたし算と引き算', boss: false, enemy: 'ガーゴイル', reward: 'tool' },
        { id: 10, name: '平均の湖', topic: '平均', boss: false, enemy: 'クラーケン', reward: 'weapon' },
        { id: 11, name: '単位の砦', topic: '単位量当たりの大きさ', boss: false, enemy: 'ナイト', reward: 'armor' },
        { id: 12, name: '2学期の城', topic: '2学期のまとめ', boss: true, enemy: '統計魔神', reward: 'special' },
        { id: 13, name: '割合の塔', topic: '割合', boss: false, enemy: 'ドラゴン', reward: 'accessory' },
        { id: 14, name: '魔王城', topic: '5年生のまとめ', boss: true, enemy: '算数魔王', reward: 'ultimate' } 
      ];
      const itemDatabase = { weapon: { 1: { name: '木の棒', rank: 1, attack: 5, effect: '基本的な武器' }, 2: { name: '鉄の剣', rank: 2, attack: 10, effect: '敵への基本ダメージ+10' }, 3: { name: '銀の剣', rank: 3, attack: 15, effect: '敵への基本ダメージ+15' }, 4: { name: '魔法の剣', rank: 4, attack: 20, effect: '敵への基本ダメージ+20' }, 5: { name: '伝説の剣', rank: 5, attack: 30, effect: '敵への基本ダメージ+30' } }, armor: { 1: { name: '布の服', rank: 1, defense: 2, effect: '被ダメージ-2' }, 2: { name: '革の鎧', rank: 2, defense: 5, effect: '被ダメージ-5' }, 3: { name: '鎖帷子', rank: 3, defense: 8, effect: '被ダメージ-8' }, 4: { name: '龍鱗の鎧', rank: 4, defense: 12, effect: '被ダメージ-12' }, 5: { name: '神聖な鎧', rank: 5, defense: 18, effect: '被ダメージ-18' } }, accessory: { 1: { name: '木の指輪', rank: 1, mp: 5, effect: 'MP自動回復+1' }, 2: { name: '銀の指輪', rank: 2, mp: 10, effect: 'MP自動回復+2' }, 3: { name: '金の指輪', rank: 3, mp: 15, effect: 'MP自動回復+3' }, 4: { name: '賢者の指輪', rank: 4, mp: 20, effect: 'MP自動回復+4' }, 5: { name: '創造の指輪', rank: 5, mp: 30, effect: 'MP自動回復+5' } }, tool: { 1: { name: '鉛筆', rank: 1, hint: 2, effect: 'ヒント使用MP-2' }, 2: { name: 'シャープペン', rank: 2, hint: 4, effect: 'ヒント使用MP-4' }, 3: { name: '万年筆', rank: 3, hint: 6, effect: 'ヒント使用MP-6' }, 4: { name: '魔法のペン', rank: 4, hint: 8, effect: 'ヒント使用MP-8' }, 5: { name: '賢者のペン', rank: 5, hint: 10, effect: 'ヒント使用MP無し' } } };
      
      const forgeRecipes = {};
      Object.keys(itemDatabase).forEach(type => {
        forgeRecipes[type] = {};
        for(let rank = 1; rank < 5; rank++) {
          const currentItem = Object.values(itemDatabase[type]).find(item => item.rank === rank);
          const nextRankItem = Object.values(itemDatabase[type]).find(item => item.rank === rank + 1);
          
          if(currentItem && nextRankItem) {
            let materials = {};
            if (rank === 1) materials = { ironOre: 5 };
            else if (rank === 2) materials = { ironOre: 10, silverOre: 3 };
            else if (rank === 3) materials = { silverOre: 5, starFragment: 2 };
            else if (rank === 4) materials = { starFragment: 5, perfectProof: 1 };
            
            forgeRecipes[type][currentItem.name] = {
                rank,
                materials,
                result: { type, ...nextRankItem }
            };
          }
        }
      });
      
      const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min; 
      const randFloat = (min, max, decimals) => parseFloat((Math.random() * (max - min) + min).toFixed(decimals));
      
      const generateProblems = (stageId, count = 20) => { 
        const problems = []; 
        
        for (let i = 0; i < count; i++) { 
            let problem = {}; 
            switch (stageId) { 
                case 1: { const problemType1 = randInt(1, 4); let num1, base1, multiplier1, result1; switch (problemType1) { case 1: num1 = randFloat(0.001, 9.999, 3); problem = { question: `${num1}は、0.001を何個集めた数ですか？`, answer: (num1 / 0.001).toString(), hint: `小数点の位置が3つ右に移動すると考えましょう。${num1} ÷ 0.001 を計算します。`, explanation: `${num1}は0.001が${num1 / 0.001}個集まった数です。計算式は ${num1} ÷ 0.001 = ${num1 / 0.001} です。`, type: "integer" }; break; case 2: base1 = randFloat(0.1, 9.9, randInt(1, 3)); multiplier1 = [10, 100, 1000][randInt(0, 2)]; result1 = formatDecimal(base1 * multiplier1); problem = { question: `${result1}は、${base1}を何倍した数ですか？`, answer: multiplier1.toString(), hint: `小数点が右にいくつ移動したか数えてみましょう。`, explanation: `${result1} ÷ ${base1} = ${multiplier1} なので、答えは${multiplier1}倍です。`, type: "integer" }; break; case 3: result1 = randFloat(0.1, 9.9, randInt(1, 3)); multiplier1 = [10, 100, 1000][randInt(0, 2)]; base1 = formatDecimal(result1 * multiplier1); problem = { question: `${result1}は、${base1}を何分の一にした数ですか？`, answer: multiplier1.toString(), hint: `小数点が左にいくつ移動したか数えてみましょう。`, explanation: `${base1}を${multiplier1}でわると${result1}になるので、${multiplier1}分の一にした数です。`, type: "integer" }; break; case 4: num1 = randFloat(0.1, 99.9, randInt(1, 3)); multiplier1 = [10, 100, 1000][randInt(0, 2)]; const isMultiplication = Math.random() < 0.5; const shiftCount = Math.log10(multiplier1); if (isMultiplication) { result1 = formatDecimal(num1 * multiplier1); problem = { question: `計算しなさい: ${num1} × ${multiplier1}`, answer: result1.toString(), hint: `小数点を右に${shiftCount}個ずらします。`, explanation: `${num1}を${multiplier1}倍すると、小数点が右に${shiftCount}個移動するので、答えは${result1}です。`, type: "decimal" }; } else { result1 = formatDecimal(num1 / multiplier1); problem = { question: `計算しなさい: ${num1} ÷ ${multiplier1}`, answer: result1.toString(), hint: `小数点を左に${shiftCount}個ずらします。`, explanation: `${num1}を${multiplier1}でわると、小数点が左に${shiftCount}個移動するので、答えは${result1}です。`, type: "decimal" }; } break; } break; }
                case 2: { const basePatterns2 = [ { type: '値段', subject: '画用紙', unit: '円', item: '枚', total: '代金', totalUnit: '円', rate: randInt(20, 50), quantity: randInt(3, 9) }, { type: '値段', subject: 'リボン', unit: '円', item: 'm', total: '代金', totalUnit: '円', rate: randInt(80, 150), quantity: randInt(3, 9) }, { type: '量', subject: '蛇口', unit: 'L', item: '分', total: '水の量', totalUnit: 'L', rate: randInt(3, 8), quantity: randInt(3, 9) }, { type: '重さ', subject: '針金', unit: 'g', item: 'm', total: '重さ', totalUnit: 'g', rate: randInt(15, 45), quantity: randInt(3, 9) }, { type: '速さ', subject: '歩行', unit: 'm', item: '分', total: '距離', totalUnit: 'm', rate: randInt(40, 80), quantity: randInt(3, 9) } ]; const p2 = basePatterns2[randInt(0, basePatterns2.length - 1)]; if (Math.random() < 0.5) { problem = { question: `1${p2.item}あたり${p2.rate}${p2.unit}の${p2.subject}があります。□${p2.item}のときの${p2.total}を〇${p2.totalUnit}とします。この関係を式に表しなさい。`, answer: `〇=${p2.rate}*□`, hint: `(全体の数) = (1つあたりの数) × (いくつ分) の形にしてみましょう。かけ算は「×」を使います。`, explanation: `全体の量(〇)は、1つあたりの量(${p2.rate})に、いくつ分か(□)をかけることで求められます。したがって、式は 〇=${p2.rate}×□ となります。`, type: "equation" }; } else { const answerValue2 = p2.rate * p2.quantity; let questionText2 = ""; switch(p2.type){ case '速さ': questionText2 = `1分間に${p2.rate}${p2.unit}の速さで歩きます。${p2.quantity}${p2.item}間では何${p2.totalUnit}進みますか？`; break; case '値段': questionText2 = `1${p2.item}${p2.rate}${p2.unit}の${p2.subject}を${p2.quantity}${p2.item}買うと、代金は何${p2.totalUnit}ですか？`; break; case '量': questionText2 = `1分間に${p2.rate}${p2.unit}ずつ水が出る${p2.subject}があります。${p2.quantity}${p2.item}間での${p2.total}は何${p2.totalUnit}になりますか？`; break; case '重さ': questionText2 = `1${p2.item}あたり${p2.rate}${p2.unit}の${p2.subject}があります。${p2.quantity}${p2.item}の${p2.total}は何${p2.totalUnit}ですか？`; break; } problem = { question: questionText2, answer: answerValue2.toString(), hint: `${p2.rate} × ${p2.quantity} = ?`, explanation: `答えは ${p2.rate} × ${p2.quantity} = ${answerValue2}${p2.totalUnit}です。`, type: "integer" }; } break; }
                case 3: { if (Math.random() < 0.5) { const patterns3 = [ { type: '面積_長方形' }, { type: '面積_正方形' }, { type: '重さ' }, { type: '液体_paint' }, { type: '液体_work' }, { type: '代金' } ]; const pattern3 = patterns3[randInt(0, patterns3.length - 1)]; let num3_1, num3_2, result3; switch (pattern3.type) { case '面積_長方形': num3_1 = randFloat(1.1, 9.9, randInt(1, 2)); num3_2 = randFloat(1.1, 9.9, randInt(1, 2)); result3 = formatDecimal(num3_1 * num3_2); problem = { question: `たて${num3_1}m、横${num3_2}mの長方形の土地があります。面積は何㎡ですか？`, answer: result3.toString(), hint: '長方形の面積は「たて × 横」で求められます。', explanation: `面積は ${num3_1} × ${num3_2} = ${result3}㎡ です。`, type: 'decimal' }; break; case '面積_正方形': num3_1 = randFloat(1.1, 9.9, randInt(1, 2)); result3 = formatDecimal(num3_1 * num3_1); problem = { question: `1辺が${num3_1}mの正方形の花だんがあります。面積は何㎡ですか？`, answer: result3.toString(), hint: '正方形の面積は「1辺 × 1辺」で求められます。', explanation: `面積は ${num3_1} × ${num3_1} = ${result3}㎡ です。`, type: 'decimal' }; break; case '液体_paint': num3_1 = randFloat(1.1, 8.5, 1); num3_2 = randFloat(1.1, 5.5, 1); result3 = formatDecimal(num3_1 * num3_2); problem = { question: `1Lで${num3_1}㎡の壁をぬれるペンキがあります。このペンキ${num3_2}Lでは、何㎡の壁をぬれますか？`, answer: result3.toString(), hint: `(1Lでぬれる面積) × (ペンキの量) を計算します。`, explanation: `ぬれる面積は ${num3_1} × ${num3_2} = ${result3}㎡ です。`, type: 'decimal' }; break; case '液体_work': num3_1 = randFloat(0.2, 1.5, 1); num3_2 = randFloat(2.5, 15.5, 1); result3 = formatDecimal(num3_1 * num3_2); problem = { question: `1㎡ぬるのに${num3_1}Lのペンキが必要です。${num3_2}㎡の壁をぬるには、ペンキが何L必要ですか？`, answer: result3.toString(), hint: `(1㎡に必要な量) × (ぬる面積) を計算します。`, explanation: `必要なペンキの量は ${num3_1} × ${num3_2} = ${result3}L です。`, type: 'decimal' }; break; case '代金': num3_1 = randInt(100, 200); num3_2 = randFloat(1.1, 3.5, 1); result3 = Math.round(formatDecimal(num3_1 * num3_2)); problem = { question: `1Lあたり${num3_1}円のジュースを${num3_2}L買います。代金は何円ですか？答えは整数で求めましょう。`, answer: result3.toString(), hint: '代金は「1Lあたりの値段 × 量」で計算し、最後に四捨五入します。', explanation: `${num3_1} × ${num3_2} = ${formatDecimal(num3_1 * num3_2)}円なので、四捨五入して${result3}円です。`, type: 'integer' }; break; default: num3_1 = randFloat(1.1, 5.5, 1); num3_2 = randFloat(1.1, 10.5, 1); result3 = formatDecimal(num3_1 * num3_2); problem = { question: `1mの重さが${num3_1}kgの鉄の棒があります。この棒${num3_2}mの重さは何kgですか？`, answer: result3.toString(), hint: `(1mあたりの重さ) × (長さ) を計算します。`, explanation: `重さは ${num3_1} × ${num3_2} = ${result3}kg です。`, type: 'decimal' }; break; } } else { const num3_1 = randFloat(1.1, 9.9, randInt(1, 2)); const num3_2 = randFloat(1.1, 9.9, randInt(1, 2)); const result3 = formatDecimal(num3_1 * num3_2); problem = { question: `計算しなさい: ${num3_1} × ${num3_2}`, answer: result3.toString(), hint: '筆算で計算してみましょう。小数点の位置に気をつけてください。', explanation: `答えは ${result3} です。`, type: 'decimal' }; } break; }
                case 4: { if (Math.random() < 0.5) { 
                    const scenarios4 = [ { item: 'ホース', unitA: 'm', quantityA: '長さ', unitB: 'kg', quantityB: '重さ' }, { item: 'ペンキ', unitA: '㎡', quantityA: '面積', unitB: 'L', quantityB: '量' }, { item: 'リボン', unitA: 'm', quantityA: '長さ', unitB: '円', quantityB: '代金' } ];
                    const s4 = scenarios4[randInt(0, scenarios4.length - 1)];
                    let valA, valB, answer, hint, explanation, qText, isApproximation = false, digits = 0;
                    
                    if (Math.random() < 0.5) { 
                        const tempAns = randFloat(1.2, 5.5, 1);
                        const smallerNum = randFloat(1.2, 5.5, 1);
                        const biggerNum = formatDecimal(tempAns * smallerNum);

                        if (Math.random() < 0.5) { 
                            valA = smallerNum; valB = biggerNum;
                            answer = formatDecimal(valB / valA).toString();
                            let questionTemplate = ""; if (s4.item === 'ペンキ') { questionTemplate = `面積が${valA}㎡の壁をぬるのに${valB}Lのペンキを使いました。1㎡あたり何Lのペンキを使いましたか？`; } else { questionTemplate = `${s4.quantityA}が${valA}${s4.unitA}の${s4.item}の${s4.quantityB}は${valB}${s4.unitB}です。この${s4.item}1${s4.unitA}あたりの${s4.quantityB}は？`; }
                            qText = questionTemplate;
                            explanation = `1${s4.unitA}あたりの${s4.quantityB}は ${valB} ÷ ${valA} = ${answer}${s4.unitB}です。`;
                            problem = { question: qText, answer, hint: `${valB} ÷ ${valA} = ?`, explanation, type: 'decimal', isApproximation };
                        } else { 
                            valA = biggerNum; valB = smallerNum;
                            answer = formatDecimal(valA / valB).toString();
                            let questionTemplate = ""; if (s4.item === 'ペンキ') { questionTemplate = `${valB}Lのペンキで${valA}㎡の壁をぬりました。ペンキ1Lあたり何㎡ぬれますか？`; } else { questionTemplate = `${s4.quantityA}が${valA}${s4.unitA}の${s4.item}の${s4.quantityB}は${valB}${s4.unitB}です。この${s4.item}1${s4.unitB}あたりの${s4.quantityA}は？`; }
                            qText = questionTemplate;
                            explanation = `1${s4.unitB}あたりの${s4.quantityA}は ${valA} ÷ ${valB} = ${answer}${s4.unitA}です。`;
                            problem = { question: qText, answer, hint: `${valA} ÷ ${valB} = ?`, explanation, type: 'decimal', isApproximation };
                        }
                    } else { 
                        isApproximation = true;
                        digits = randInt(2, 3);
                        let divisor_raw, dividend_raw; 
                        do {
                            divisor_raw = randFloat(2.1, 9.9, 1);
                            dividend_raw = randFloat(divisor_raw + 0.1, divisor_raw * 5, 1);
                        } while (dividend_raw % divisor_raw === 0 || formatDecimal(dividend_raw / divisor_raw) < 1);

                        if (Math.random() < 0.5) { 
                            valA = divisor_raw; valB = dividend_raw;
                            answer = (valB / valA).toPrecision(digits); // toPrecisionで概数文字列を生成
                            let questionTemplate = ""; if (s4.item === 'ペンキ') { questionTemplate = `面積が${valA}㎡の壁をぬるのに${valB}Lのペンキを使いました。1㎡あたり何Lのペンキを使いましたか？`; } else { questionTemplate = `${s4.quantityA}が${valA}${s4.unitA}の${s4.item}の${s4.quantityB}は${valB}${s4.unitB}です。この${s4.item}1${s4.unitA}あたりの${s4.quantityB}は？`; }
                            qText = questionTemplate + ` (答えは上から${digits}けたのがい数で)`;
                            explanation = `${valB} ÷ ${valA} ≒ ${answer}${s4.unitB}です。`;
                            problem = { question: qText, answer, hint: `${valB} ÷ ${valA} = ?`, explanation, type: 'decimal', isApproximation, digits };
                        } else { 
                            valA = dividend_raw; valB = divisor_raw;
                            answer = (valA / valB).toPrecision(digits);
                            let questionTemplate = ""; if (s4.item === 'ペンキ') { questionTemplate = `${valB}Lのペンキで${valA}㎡の壁をぬりました。ペンキ1Lあたり何㎡ぬれますか？`; } else { questionTemplate = `${s4.quantityA}が${valA}${s4.unitA}の${s4.item}の${s4.quantityB}は${valB}${s4.unitB}です。この${s4.item}1${s4.unitB}あたりの${s4.quantityA}は？`; }
                            qText = questionTemplate + ` (答えは上から${digits}けたのがい数で)`;
                            explanation = `${valA} ÷ ${valB} ≒ ${answer}${s4.unitA}です。`;
                            problem = { question: qText, answer, hint: `${valA} ÷ ${valB} = ?`, explanation, type: 'decimal', isApproximation, digits };
                        }
                    }
                } else { 
                    let dividend, divisor, answer;
                    if (Math.random() < 0.5) { 
                        answer = randFloat(1.1, 9.9, 1);
                        divisor = randFloat(1.1, 9.9, 1);
                        dividend = formatDecimal(answer * divisor);
                        problem = { question: `計算しなさい: ${dividend} ÷ ${divisor}`, answer: answer.toString(), hint: '小数点の位置に注意して筆算しましょう。', explanation: `${dividend} ÷ ${divisor} = ${answer}です。`, type: 'decimal' };
                    } else { 
                        const digits = randInt(2, 3);
                        do {
                            divisor = randFloat(2.1, 9.9, 1);
                            dividend = randFloat(divisor + 0.1, divisor * 5, 1);
                        } while (dividend % divisor === 0);
                        answer = (dividend / divisor).toPrecision(digits);
                        problem = { question: `計算しなさい: ${dividend} ÷ ${divisor} (答えは上から${digits}けたのがい数で)`, answer: answer, hint: `わり算をして、上から${digits + 1}けた目を四捨五入します。`, explanation: `${dividend} ÷ ${divisor} ≒ ${answer}です。`, type: 'decimal', isApproximation: true, digits: digits };
                    }
                } break; }
                case 5: { const problemType5 = randInt(1, 4); let baseValue5, compareValue5, ratio5, problemContext5; switch (problemType5) { case 1: problemContext5 = [ { itemA: '赤のリボン', itemB: '青のリボン', unit: 'm' }, { itemA: '公園の面積', itemB: '学校の面積', unit: '㎡' }, { itemA: '弟の体重', itemB: '兄の体重', unit: 'kg' } ][randInt(0, 2)]; ratio5 = [1.25, 1.5, 0.8, 2.5, 0.4][randInt(0, 4)]; baseValue5 = randInt(10, 50); compareValue5 = formatDecimal(baseValue5 * ratio5); if (Math.random() < 0.5) { problem = { question: `${problemContext5.itemA}は${baseValue5}${problemContext5.unit}、${problemContext5.itemB}は${compareValue5}${problemContext5.unit}です。${problemContext5.itemA}をもとにすると、${problemContext5.itemB}は何倍ですか。`, answer: ratio5.toString(), hint: '「〜をもとにすると」の「〜」がわる数になります。 (比べる量) ÷ (もとにする量) を計算します。', explanation: `${compareValue5} ÷ ${baseValue5} = ${ratio5} なので、答えは${ratio5}倍です。`, type: 'decimal' }; } else { problem = { question: `${problemContext5.itemA}は${baseValue5}${problemContext5.unit}、${problemContext5.itemB}は${compareValue5}${problemContext5.unit}です。${problemContext5.itemB}は${problemContext5.itemA}の何倍ですか。`, answer: ratio5.toString(), hint: '「〜の何倍」の「〜」がわる数になります。 (比べる量) ÷ (もとにする量) を計算します。', explanation: `${compareValue5} ÷ ${baseValue5} = ${ratio5} なので、答えは${ratio5}倍です。`, type: 'decimal' }; } break; case 2: problemContext5 = [ { itemA: '赤のテープ', itemB: '白のテープ', unit: 'm' }, { itemA: '昨日の来場者数', itemB: '今日の来場者数', unit: '人' }, { itemA: '定価', itemB: 'セール価格', unit: '円' } ][randInt(0, 2)]; baseValue5 = randInt(100, 500); ratio5 = [0.8, 1.2, 1.5, 0.9][randInt(0, 3)]; compareValue5 = formatDecimal(baseValue5 * ratio5); problem = { question: `${problemContext5.itemA}は${baseValue5}${problemContext5.unit}です。${problemContext5.itemA}をもとにすると、${problemContext5.itemB}は${ratio5}倍です。${problemContext5.itemB}は何${problemContext5.unit}ですか。`, answer: compareValue5.toString(), hint: '(もとにする量) × (割合) を計算します。', explanation: `${baseValue5} × ${ratio5} = ${compareValue5} なので、答えは${compareValue5}${problemContext5.unit}です。`, type: 'decimal' }; break; case 3: problemContext5 = [ { itemA: '生まれた時の体重', itemB: '今の体重', unit: 'g' }, { itemA: '先月の貯金', itemB: '今月の貯金', unit: '円' }, { itemA: '本の全体のページ数', itemB: '読んだページ数', unit: 'ページ' } ][randInt(0, 2)]; baseValue5 = randInt(20, 80) * 10; ratio5 = [1.2, 1.5, 1.8, 2.5, 0.7][randInt(0, 4)]; compareValue5 = formatDecimal(baseValue5 * ratio5); problem = { question: `${problemContext5.itemB}は${compareValue5}${problemContext5.unit}で、これは${problemContext5.itemA}の${ratio5}倍です。${problemContext5.itemA}は何${problemContext5.unit}ですか。`, answer: baseValue5.toString(), hint: '(比べる量) ÷ (割合) を計算します。', explanation: `${compareValue5} ÷ ${ratio5} = ${baseValue5} なので、答えは${baseValue5}${problemContext5.unit}です。`, type: 'decimal' }; break; case 4: const r1_5 = [0.75, 0.8, 0.85, 0.9][randInt(0,3)]; let r2_5; do { r2_5 = [0.7, 0.75, 0.8, 0.85, 0.9][randInt(0,4)]; } while(r1_5 === r2_5); const item1_5 = { name: 'おにぎり', base: randInt(15, 20) * 10, ratio: r1_5 }; item1_5.compare = Math.round(item1_5.base * item1_5.ratio); const item2_5 = { name: 'ハンバーガー', base: randInt(20, 30) * 10, ratio: r2_5 }; item2_5.compare = Math.round(item2_5.base * item2_5.ratio); const answer5_4 = item1_5.ratio < item2_5.ratio ? 1 : 2; problem = { question: `元のねだんが${item1_5.base}円で値引き後のねだんが${item1_5.compare}円の${item1_5.name}（１）と、元のねだんが${item2_5.base}円で値引き後のねだんが${item2_5.compare}円の${item2_5.name}（２）があります。より割引率が高い（安くなった割合が大きい）のはどちらですか。数字で答えなさい。`, answer: answer5_4.toString(), hint: 'それぞれの「値引き後 ÷ 元のねだん」を計算し、結果が小さい方を選びます。', explanation: `${item1_5.name}の割合は${item1_5.ratio}、${item2_5.name}の割合は${item2_5.ratio}。${answer5_4}の方がより安くなっています。`, type: 'integer' }; break; } break; }
                case 6: case 12: case 14: break; // ボスステージは問題生成ロジックが異なるためスキップ
                case 7: { const problemType7 = randInt(1, 3); switch (problemType7) { case 1: const num7 = randInt(1, 1000); const isOdd7 = num7 % 2 !== 0; problem = { question: `数「${num7}」はどちらですか？\n1. 奇数, 2. 偶数`, answer: isOdd7 ? "1" : "2", hint: "一の位の数字が0, 2, 4, 6, 8なら偶数、1, 3, 5, 7, 9なら奇数です。", explanation: `${num7}は2で${isOdd7 ? '割り切れないので奇数(1)' : '割り切れるので偶数(2)'}です。`, type: "integer" }; break; case 2: let n1_lcm = randInt(2, 9), n2_lcm = randInt(2, 12); while(n1_lcm === n2_lcm) n2_lcm = randInt(2,12); let nums_lcm = [n1_lcm, n2_lcm]; if(Math.random() > 0.7) { let n3_lcm = randInt(2,8); while(nums_lcm.includes(n3_lcm)) n3_lcm = randInt(2,8); nums_lcm.push(n3_lcm); } const resultLcm = lcm(...nums_lcm); problem = { question: `${nums_lcm.join(' と ')} の最小公倍数はいくつですか？`, answer: resultLcm.toString(), hint: "それぞれの数の倍数を書き出していき、最初に出てくる共通の数を見つけましょう。", explanation: `答えは ${resultLcm} です。`, type: "integer" }; break; case 3: const commonDivisor7 = randInt(2, 5); let n1_gcd = commonDivisor7 * randInt(2, 4); let n2_gcd = commonDivisor7 * randInt(5, 7); let nums_gcd = [...new Set([n1_gcd, n2_gcd])]; if (nums_gcd.length < 2) nums_gcd = [commonDivisor7*2, commonDivisor7*3]; const resultGcd = gcd(...nums_gcd); problem = { question: `${nums_gcd.join(' と ')} の最大公約数はいくつですか？`, answer: resultGcd.toString(), hint: "それぞれの数の約数を書き出していき、一番大きい共通の数を見つけましょう。", explanation: `答えは ${resultGcd} です。`, type: "integer" }; break; } break; }
                case 8: { const problemType8 = randInt(1, 5); let num8, den8, val8, scenarios8, s8, base8, compare8; switch (problemType8) { case 1: den8 = randInt(2, 12); num8 = randInt(1, den8 - 1); problem = { question: `分数 ${num8}/${den8} をわり算の式に直しなさい。`, answer: [num8.toString(), den8.toString()], hint: `分数の横棒「―」は、わり算の「÷」と同じ意味です。`, explanation: `分数は「分子 ÷ 分母」で表せます。なので、${num8} ÷ ${den8} となります。`, type: 'division_form' }; break; case 2: if (Math.random() < 0.5) { den8 = [2, 4, 5, 8, 10][randInt(0, 4)]; num8 = randInt(1, den8 * 2); while (num8 % den8 === 0) { num8 = randInt(1, den8 * 2); } } else { den8 = randInt(2, 5); num8 = den8 * randInt(2, 5); } problem = { question: `分数 ${num8}/${den8} を小数または整数で表しなさい。`, answer: (num8 / den8).toString(), hint: `分子 ÷ 分母 を計算します。`, explanation: `${num8} ÷ ${den8} = ${num8/den8} です。`, type: 'decimal' }; break; case 3: if (Math.random() < 0.6) { const decimals = [10, 100][randInt(0, 1)]; num8 = randInt(1, decimals - 1); val8 = num8 / decimals; problem = { question: `小数 ${val8} を分数で表しなさい。`, answer: `${num8}/${decimals}`, hint: `小数第一位なら分母は10、小数第二位なら分母は100になります。`, explanation: `${val8}は${num8}/${decimals}と表せます。`, type: 'fraction' }; } else { num8 = randInt(2, 20); problem = { question: `整数 ${num8} を分数で表しなさい。`, answer: `${num8}/1`, hint: `どんな整数も、分母を1にすることで分数にできます。`, explanation: `整数${num8}は、分母を1にして ${num8}/1 と表せます。`, type: 'fraction' }; } break; case 4: scenarios8 = [ { unit: 'm', item: 'リボン' }, { unit: 'kg', item: '荷物' }, { unit: 'L', item: 'ジュース' }, { unit: '人', item: 'クラス' } ]; s8 = scenarios8[randInt(0, scenarios8.length - 1)]; base8 = randInt(2, 20); compare8 = randInt(2, 20); while (base8 === compare8) { compare8 = randInt(2, 20); } problem = { question: `${compare8}${s8.unit}は${base8}${s8.unit}の何倍ですか。分数で答えなさい。`, answer: `${compare8}/${base8}`, hint: '「AはBの何倍か」は A÷B で計算し、わり算の形をそのまま分数にします。', explanation: `${compare8}÷${base8} は分数で ${compare8}/${base8} となります。`, type: 'fraction' }; break; case 5: scenarios8 = [ { unit: 'cm', item: 'テープ' }, { unit: 'g', item: '粘土' }, { unit: '円', item: 'お菓子' }, { unit: 'dL', item: '牛乳' } ]; s8 = scenarios8[randInt(0, scenarios8.length - 1)]; base8 = randInt(2, 20); compare8 = randInt(2, 20); while (base8 === compare8) { compare8 = randInt(2, 20); } problem = { question: `${base8}${s8.unit}を1とみると、${compare8}${s8.unit}はいくつにあたりますか。分数で答えなさい。`, answer: `${compare8}/${base8}`, hint: '「Aを1とみる」は A をもとにする、つまり A でわるということです。B÷Aを分数にします。', explanation: `${compare8}÷${base8} なので、答えは分数で ${compare8}/${base8} です。`, type: 'fraction' }; break; } break; }
                case 9: { if (Math.random() < 0.5) { let d1, d2, finalLcm, n1, n2, result_n, question_text; if (Math.random() < 0.5) { do { d1 = randInt(2, 6); d2 = randInt(3, 8); } while (lcm(d1, d2) > 30 || d1 === d2); finalLcm = lcm(d1, d2); n1 = randInt(1, d1 - 1); n2 = randInt(1, d2 - 1); result_n = n1 * (finalLcm / d1) + n2 * (finalLcm / d2); question_text = `分数で計算しなさい: ${n1}/${d1} + ${n2}/${d2}`; } else { d1 = randInt(10, 24); finalLcm = d1; n1 = randInt(1, d1 - 1); n2 = randInt(1, d1 - 1); result_n = n1 + n2; question_text = `分数で計算しなさい: ${n1}/${d1} + ${n2}/${d1}`; } const commonDivisor9 = gcd(result_n, finalLcm); const final_n = result_n / commonDivisor9; const final_d = finalLcm / commonDivisor9; if (final_d === 1) { problem = { question: question_text, answer: final_n.toString(), hint: "まず通分して計算し、最後に約分します。答えが整数になるかもしれません。", explanation: `計算結果は ${result_n}/${finalLcm} となり、約分すると ${final_n} になります。`, type: "integer" }; } else { problem = { question: question_text, answer: `${final_n}/${final_d}`, hint: "まず通分して計算し、最後に必ず約分します。", explanation: `計算結果は ${result_n}/${finalLcm} となり、約分すると ${final_n}/${final_d} です。`, type: "fraction" }; } } else { let timeVal9, baseUnit9, question_text9; if (Math.random() < 0.5) { timeVal9 = randInt(1, 59); baseUnit9 = 60; question_text9 = `${timeVal9}分は何時間ですか。約分した分数で答えなさい。`; } else { timeVal9 = randInt(1, 59); baseUnit9 = 60; question_text9 = `${timeVal9}秒は何分ですか。約分した分数で答えなさい。`; } const commonDivisor9_2 = gcd(timeVal9, baseUnit9); const final_n9_2 = timeVal9 / commonDivisor9_2; const final_d9_2 = baseUnit9 / commonDivisor9_2; problem = { question: question_text9, answer: `${final_n9_2}/${final_d9_2}`, hint: `分母を60として分数を作り、最後に必ず約分します。`, explanation: `${timeVal9}/${baseUnit9} を約分すると ${final_n9_2}/${final_d9_2} になります。`, type: "fraction" }; } break; }
                case 10: { const scenarios10 = [ { subject: 'テスト', unit: '点', min: 50, max: 100 }, { subject: '身長', unit: 'cm', min: 140, max: 170 }, { subject: '読書', unit: 'ページ', min: 15, max: 50 }, { subject: 'ゲームのスコア', unit: '点', min: 1000, max: 5000 }, { subject: 'リンゴの重さ', unit: 'g', min: 250, max: 350 } ]; const scenario10 = scenarios10[randInt(0, scenarios10.length - 1)]; const count10 = randInt(2, 5); let values10 = Array.from({ length: count10 }, () => randInt(scenario10.min, scenario10.max)); let sum10 = values10.reduce((a, b) => a + b, 0); if (Math.random() < 0.5) { const remainder10 = sum10 % count10; if (remainder10 !== 0) { const diff10 = remainder10; // remainder10は0からcount10-1
                     // 値を調整して割り切れるようにする
                    if (values10[count10 - 1] - diff10 >= scenario10.min) {
                        values10[count10 - 1] -= diff10;
                    } else if (values10[0] + (count10 - diff10) <= scenario10.max) {
                        values10[0] += (count10 - diff10);
                    } else { // 調整が難しい場合、他の値を調整するか、別の問題生成を試みる
                        // ここでは単純に問題をスキップして再生成させる（後で filter で除外される）
                        problem = {}; 
                        break;
                    }
                    sum10 = values10.reduce((a, b) => a + b, 0);
                } const avg10 = sum10 / count10; problem = { question: `${count10}日間の${scenario10.subject}の記録が ${values10.join(`${scenario10.unit}, `)}${scenario10.unit}でした。平均は何${scenario10.unit}ですか？`, answer: avg10.toString(), hint: `まず全ての記録を合計し、その合計を日数（${count10}）で割ります。`, explanation: `合計は ${sum10} です。平均は ${sum10} ÷ ${count10} = ${avg10}${scenario10.unit}です。`, type: "integer" }; } else { if (sum10 % count10 === 0) { values10[0] = Math.min(values10[0] + 1, scenario10.max); // 割り切れないように調整
                                sum10++; } const avg10 = sum10 / count10; const roundedAvg10 = Math.round(avg10); problem = { question: `${count10}日間の${scenario10.subject}の記録が ${values10.join(`${scenario10.unit}, `)}${scenario10.unit}でした。平均はおよそ何${scenario10.unit}ですか？小数第一位を四捨五入して整数で答えなさい。`, answer: roundedAvg10.toString(), hint: `まず合計を計算し、日数（${count10}）で割ります。その後、答えを四捨五入します。`, explanation: `合計 ${sum10} ÷ ${count10} = ${avg10.toFixed(2)}... となります。小数第一位を四捨五入して、答えは ${roundedAvg10}${scenario10.unit}です。`, type: "integer" }; } break; }
                case 11: { const problemType11 = randInt(1, 3); let speed11, time11, distance11, question11, answer11, hint11, explanation11; switch (problemType11) { case 1: if (Math.random() < 0.5) { time11 = randInt(2, 10); distance11 = randInt(100, 500) * time11; speed11 = (distance11 / 1000) / (time11 / 60); question11 = `${distance11}mの道のりを${time11}分で走る自転車の時速は何kmですか？`; answer11 = formatDecimal(speed11).toString(); hint11 = `道のりをkmに、時間をhに直してから計算します。${distance11}m = ${distance11/1000}km, ${time11}分 = ${time11/60}時間`; explanation11 = `時速 = ${distance11/1000}km ÷ ${time11/60}h = ${answer11}km/hです。`; } else { time11 = randInt(2, 5); speed11 = randInt(3, 12) * time11; distance11 = (speed11 * 1000) / 60; question11 = `時速${speed11}kmで走るランナーの分速は何mですか？`; answer11 = Math.round(distance11).toString(); hint11 = `時速を分速に、kmをmに直します。1km=1000m, 1時間=60分`; explanation11 = `分速 = (${speed11} × 1000)m ÷ 60分 = ${answer11}m/分です。`; } problem = { question: question11, answer: answer11, hint: hint11, explanation: explanation11, type: 'decimal' }; break; case 2: if (Math.random() < 0.5) { speed11 = randInt(60, 120); time11 = randInt(2, 5) * 10; distance11 = speed11 * (time11 / 60) * 1000; question11 = `時速${speed11}kmで進む電車は、${time11}分で何m進みますか？`; answer11 = distance11.toString(); hint11 = `道のり(m) = (時速(km) × 1000) ÷ 60 × 時間(分)`; explanation11 = `道のり(m) = (${speed11} × 1000) ÷ 60 × ${time11} = ${answer11}mです。`; } else { speed11 = randInt(50, 100); time11 = randInt(15, 45); distance11 = speed11 * time11; question11 = `分速${speed11}mで歩く人は、${time11}分で何m進みますか？`; answer11 = distance11.toString(); hint11 = "道のり(m) = 速さ(m/分) × 時間(分)"; explanation11 = `${speed11} × ${time11} = ${answer11}。答えは${answer11}mです。`; } problem = { question: question11, answer: answer11, hint: hint11, explanation: explanation11, type: 'integer' }; break; case 3: if (Math.random() < 0.5) { speed11 = randInt(50, 100); time11 = randInt(10, 20); distance11 = speed11 * time11; question11 = `${distance11}mの道のりを分速${speed11}mで歩くと何分かかりますか？`; answer11 = time11.toString(); hint11 = "時間(分) = 道のり(m) ÷ 速さ(m/分)"; explanation11 = `${distance15} ÷ ${speed11} = ${answer11}。答えは${answer11}分です。`; } else { speed11 = randInt(20, 60); time11 = randInt(2, 6); distance11 = speed11 * time11; question11 = `${distance11}kmの道のりを時速${speed11}kmで走る車は何時間かかりますか？`; answer11 = time11.toString(); hint11 = "時間(h) = 道のり(km) ÷ 速さ(km/時)"; explanation11 = `${distance11} ÷ ${speed11} = ${answer11}。答えは${answer11}時間です。`; } problem = { question: question11, answer: answer11, hint: hint11, explanation: explanation11, type: "integer" }; break; } break; }
                case 13: { const problemType13 = randInt(1, 3); let base13, compare13, ratio13, question13, answer13, hint13, explanation13; switch (problemType13) { case 1: const scenarios13_1 = [ { type: 'percent_of', context: "定員", item: "人", base: randInt(10, 50) * 10, unit: "人" }, { type: 'percent_of', context: "面積", item: "畑", base: randInt(10, 30) * 10, unit: "㎡" }, { type: 'discount', context: "定価", item: "商品", base: randInt(20, 80) * 100, unit: "円" } ]; const s13_1 = scenarios13_1[randInt(0, scenarios13_1.length - 1)]; if (s13_1.type === 'discount') { ratio13 = randInt(10, 40); compare13 = Math.round(s13_1.base * (1 - ratio13 / 100)); question13 = `${s13_1.context}が${s13_1.base}${s13_1.unit}の${s13_1.item}があります。この${s13_1.item}を${ratio13}%引きで買うと、値段は何${s13_1.unit}ですか？`; answer13 = compare13.toString(); hint13 = `まず割引額を計算するか、残りの割合を計算します。残りの割合は${100 - ratio13}%です。`; explanation13 = `割引後の値段は、元の値段に(1 - 割引率)をかけて求めます。${s13_1.base} × (1 - ${ratio13/100}) = ${compare13}。答えは${compare13}${s13_1.unit}です。`; } else { ratio13 = randInt(10, 90); compare13 = Math.round(s13_1.base * (ratio13 / 100)); question13 = `${s13_1.context}が${s13_1.base}${s13_1.unit}の${s13_1.item}があります。${s13_1.context}の${ratio13}%が使われています。使われているのは何${s13_1.unit}ですか？`; answer13 = compare13.toString(); hint13 = `(もとにする量) × (割合) を計算します。${ratio13}%は小数で${ratio13/100}です。`; explanation13 = `${s13_1.base} × ${ratio13/100} = ${compare13}。答えは${compare13}${s13_1.unit}です。`; } problem = { question: question13, answer: answer13, hint: hint13, explanation: explanation13, type: 'integer' }; break; case 2: const scenarios13_2 = [ { context: "割引後の値段", item: "服", unit: "円" }, { context: "男子の人数", item: "クラス", unit: "人" }, { context: "使った量", item: "ジュース", unit: "mL" } ]; const s13_2 = scenarios13_2[randInt(0, scenarios13_2.length - 1)]; ratio13 = randInt(2, 8) * 10; if (s13_2.context === "割引後の値段") { const discount13 = ratio13; base13 = randInt(20, 50) * 100; compare13 = Math.round(base13 * (1 - discount13/100)); question13 = `${discount13}%引きで買った${s13_2.item}の値段が${compare13}${s13_2.unit}でした。この${s13_2.item}の元の値段は何${s13_2.unit}ですか？`; hint13 = `(比べる量) ÷ (割合) を計算します。${discount13}%引きは元の${100 - discount13}%です。`; explanation13 = `割引後の割合は ${100 - discount13}% = ${1-discount13/100} です。よって、${compare13} ÷ ${1-discount13/100} = ${base13}。答えは${base13}${s13_2.unit}です。`; } else { base13 = randInt(20, 50) * 10; compare13 = Math.round(base13 * (ratio13 / 100)); question13 = `${s13_2.context}が${compare13}${s13_2.unit}でした。これは全体の${ratio13}%にあたります。全体の量は何${s13_2.unit}ですか？`; hint13 = `(比べる量) ÷ (割合) を計算します。${ratio13}%は小数で${ratio13/100}です。`; explanation13 = `${compare13} ÷ ${ratio13/100} = ${base13}。全体の量は${base13}${s13_2.unit}です。`; } answer13 = base13.toString(); problem = { question: question13, answer: answer13, hint: hint13, explanation: explanation13, type: 'integer' }; break; case 3: const scenarios13_3 = [ { base_item: "学校の全校生徒", compare_item: "男子生徒", unit: "人" }, { base_item: "おこづかい", compare_item: "貯金額", unit: "円" }, { base_item: "シュートした本数", compare_item: "ゴールした本数", unit: "本" } ]; const s13_3 = scenarios13_3[randInt(0, scenarios13_3.length - 1)]; base13 = randInt(20, 50) * 10; compare13 = randInt(1, 9) * (base13 / 10); ratio13 = Math.round((compare13 / base13) * 100); question13 = `${s13_3.base_item}が${base13}${s13_3.unit}で、そのうち${s13_3.compare_item}が${compare13}${s13_3.unit}です。${s13_3.compare_item}の割合は何%ですか？`; answer13 = ratio13.toString(); hint13 = `(比べる量) ÷ (もとにする量) を計算し、最後に100をかけて%にします。`; explanation13 = `${compare13} ÷ ${base13} = ${compare13/base13}。これに100をかけて、${ratio13}%です。`; problem = { question: question13, answer: answer13, hint: hint13, explanation: explanation13, type: 'integer' }; break; } break; }
                default: problem = { question: `1 + 1 は？`, answer: "2", hint: "指を使ってみよう", explanation: "1と1を足すと2になります。", type: "integer" };
            } 
            if (Object.keys(problem).length > 0) problems.push(problem); 
        } 
        return problems; 
      };

      const canEnterStage = (stage) => {
        if (stage.id === 1) return true;
        return playerData.clearedStages.includes(stage.id - 1);
      };

      useEffect(() => { 
        if (gameState === GAME_STATES.BATTLE && currentProblem) { 
            setUserAnswer(''); setFractionTop(''); setFractionBottom(''); 
            setDivisionNumerator(''); setDivisionDenominator('');
            setShowHint(false); setShowExplanation(false); setBattleFeedback({ player: '', enemy: '' }); 
            const type = currentProblem.type;
            if(type === 'fraction') setActiveInput('fractionTop');
            else if (type === 'division_form') setActiveInput('divisionNumerator');
            else setActiveInput('answer');
        } 
      }, [currentProblem, gameState]);
      
      useEffect(() => { if (itemGetNotification) { const timer = setTimeout(() => setItemGetNotification(null), 3500); return () => clearTimeout(timer); } }, [itemGetNotification]);
      useEffect(() => { if (materialGetNotification) { const timer = setTimeout(() => setMaterialGetNotification(null), 3500); return () => clearTimeout(timer); } }, [materialGetNotification]);
      useEffect(() => { if (levelUpNotification) { const timer = setTimeout(() => setLevelUpNotification(null), 4000); return () => clearTimeout(timer); } }, [levelUpNotification]); // Level up notification timeout

      const saveGameToFile = () => {
        try {
          const dataString = JSON.stringify(playerData);
          const blob = new Blob([dataString], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          const date = new Date();
          const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
          link.href = url;
          link.download = `sansu-quest-save_${dateString}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          alert('冒険の書をファイルに保存しました！');
        } catch (error) {
          console.error("Save failed:", error);
          alert('セーブに失敗しました。');
        }
      };

      const loadGameFromFile = () => { fileInputRef.current.click(); };
      
      const handleFileSelect = (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const dataString = e.target.result;
            const loadedData = JSON.parse(dataString);
            // 必須プロパティのチェックで最低限のバリデーション
            if (loadedData && typeof loadedData.level === 'number' && Array.isArray(loadedData.inventory) && typeof loadedData.hp === 'number') {
              setPlayerData(loadedData);
              alert('冒険の書を読み込みました！');
              changeGameState(GAME_STATES.STAGE_SELECT);
            } else { throw new Error('Invalid save file format.'); }
          } catch (error) {
            console.error("Load failed:", error);
            alert('セーブファイルが正しくないか、データが壊れています。');
          }
        };
        reader.onerror = () => { alert('ファイルの読み込みに失敗しました。'); };
        reader.readAsText(file);
        // ファイル選択ダイアログをリセット
        event.target.value = null; 
      };

      const startBattle = (stage) => { 
        setPlayerData(prev => ({ ...prev, hp: prev.maxHp, mp: prev.maxMp })); 
        setCurrentStage(stage); 
        let problemsToUse = []; 
        if (stage.id === 14) { 
            // 魔王城は全ステージの問題からランダムに5問ずつ
            [1,2,3,4,5,7,8,9,10,11,13].forEach(id => problemsToUse.push(...generateProblems(id, 5))); 
        } 
        else if (stage.id === 6) { 
            // 1学期のまとめは1-5ステージから4問ずつ
            [1,2,3,4,5].forEach(id => problemsToUse.push(...generateProblems(id, 4))); 
        } 
        else if (stage.id === 12) { 
            // 2学期のまとめは7-11ステージから4問ずつ
            [7,8,9,10,11].forEach(id => problemsToUse.push(...generateProblems(id, 4))); 
        } 
        else { 
            // 通常ステージ
            problemsToUse = generateProblems(stage.id, 30); 
        } 
        const shuffled = [...problemsToUse].sort(() => 0.5 - Math.random()); 
        setBattleProblems(shuffled); 
        setCurrentProblem(shuffled[0]); 
        setCurrentProblemIndex(0); 
        const enemyMaxHp = stage.boss ? (stage.id === 14 ? 500 : 300) : 100; 
        setEnemyHp(enemyMaxHp); 
        setMaxEnemyHp(enemyMaxHp); 
        setBattleResult(null); 
        setGameOver(false); 
        setEnemyDefeated(false);
        setPlayerData(prev => ({ ...prev, battleStats: { ...initialPlayerData.battleStats }, wrongProblems: [] })); 
        changeGameState(GAME_STATES.BATTLE); 
      };
      
      const handlePadInput = (key) => {
        if (showExplanation) return; // 解説表示中は入力不可
        
        const setters = {
            answer: setUserAnswer,
            fractionTop: setFractionTop,
            fractionBottom: setFractionBottom,
            divisionNumerator: setDivisionNumerator,
            divisionDenominator: setDivisionDenominator,
        };
        const currentSetter = setters[activeInput];
        if (!currentSetter) return;

        if (key === '⌫') { currentSetter(prev => prev.slice(0, -1)); } 
        else if (key === 'C') { currentSetter(''); } 
        else { 
            // 数字または小数点、または式記号のみ許可
            const allowedKeys = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', '〇', '□', '=', '×', '+', '-'];
            if (allowedKeys.includes(key)) {
                currentSetter(prev => prev + key); 
            }
        }
      };

      const checkAnswer = () => {
        if (!currentProblem || showExplanation) return;
        
        let userAnswerValue = userAnswer.trim();
        let isCorrect = false;

        if (currentProblem.type === 'fraction') {
          const userNum = parseInt(fractionTop, 10);
          const userDen = parseInt(fractionBottom, 10);

          if (!isNaN(userNum) && !isNaN(userDen) && userDen !== 0) {
            const [correctNum, correctDen] = currentProblem.answer.split('/').map(Number);
            
            // 両方の分数を約分して比較
            const correctCommonDivisor = gcd(correctNum, correctDen);
            const simplifiedCorrectNum = correctNum / correctCommonDivisor;
            const simplifiedCorrectDen = correctDen / correctCommonDivisor;

            const userCommonDivisor = gcd(userNum, userDen);
            const simplifiedUserNum = userNum / userCommonDivisor;
            const simplifiedUserDen = userDen / userCommonDivisor;

            isCorrect = (simplifiedCorrectNum === simplifiedUserNum && simplifiedCorrectDen === simplifiedUserDen);
          } else { 
            isCorrect = false; 
          }
          userAnswerValue = `${fractionTop}/${fractionBottom}`; // 記録用にユーザーの入力形式を保持
        } else if (currentProblem.type === 'division_form') {
          isCorrect = divisionNumerator === currentProblem.answer[0] && divisionDenominator === currentProblem.answer[1];
          userAnswerValue = `${divisionNumerator} ÷ ${divisionDenominator}`;
        } else if (currentProblem.type === 'equation') {
          // 空白と全角/半角記号を正規化して比較
          isCorrect = userAnswerValue.replace(/\s/g, '').replace(/×/g, '*') === currentProblem.answer.replace(/\s/g, '');
        } else if (currentProblem.isApproximation) {
            const userValue = parseFloat(userAnswerValue);
            const correctApproxAnswer = parseFloat(currentProblem.answer); // 問題生成時にtoPrecisionで丸められた文字列

            if (!isNaN(userValue)) {
                // ユーザーの答えを、問題で指定された桁数で四捨五入する
                // 例: digits=3 (上から3桁) -> pow10=100
                const pow10 = Math.pow(10, currentProblem.digits - 1); 
                const roundedUserValue = Math.round(userValue * pow10) / pow10;
                
                // 正解の概数と比較 (浮動小数点誤差を考慮)
                isCorrect = Math.abs(roundedUserValue - correctApproxAnswer) < 1e-9;
            } else {
                isCorrect = false;
            }
        } else { // type: 'decimal' or 'integer' (非概数)
            isCorrect = Math.abs(parseFloat(userAnswerValue) - parseFloat(currentProblem.answer)) < 1e-9;
        }
        
        let updatedPlayerData = { ...playerData }; 
        let newEnemyHp = enemyHp; 
        let feedback = { player: '', enemy: '' }; 
        const newConsecutiveCorrect = isCorrect ? playerData.battleStats.consecutiveCorrect + 1 : 0; 
        
        updatedPlayerData.battleStats = { 
            ...playerData.battleStats, 
            totalProblems: playerData.battleStats.totalProblems + 1, 
            correctAnswers: playerData.battleStats.correctAnswers + (isCorrect ? 1 : 0), 
            consecutiveCorrect: newConsecutiveCorrect 
        }; 

        if (isCorrect) { 
            const weapon = playerData.equipment.weapon; 
            const weaponMultiplier = weapon ? rankMultipliers[weapon.rank] : 1; 
            const baseDamage = 30; // 基本ダメージ
            const equipmentDamage = weapon ? weapon.attack * weaponMultiplier : 0; // 武器によるダメージ
            const totalDamage = Math.round(baseDamage + equipmentDamage);
            
            if (!enemyDefeated) {
                newEnemyHp = Math.max(0, enemyHp - totalDamage);
                feedback.enemy = `-${totalDamage}`;
                if (newEnemyHp <= 0) {
                    setEnemyDefeated(true);
                }
            }
            
            updatedPlayerData.exp += 10;
            updatedPlayerData = checkForLevelUp(updatedPlayerData);
            
            if (newConsecutiveCorrect > 0 && newConsecutiveCorrect % 5 === 0) { 
                updatedPlayerData.mp = Math.min(updatedPlayerData.maxMp, updatedPlayerData.mp + 20); 
            } 
            setPlayerData(updatedPlayerData);
            setEnemyHp(newEnemyHp);
            setBattleFeedback(feedback);
            checkStageConditions(updatedPlayerData.battleStats, newEnemyHp <= 0 || enemyDefeated);
        } else { 
            const armor = playerData.equipment.armor; 
            const armorMultiplier = armor ? rankMultipliers[armor.rank] : 1; 
            const baseDamage = 20; 
            const defense = armor ? armor.defense * armorMultiplier : 0; 
            const actualDamage = Math.max(1, Math.round(baseDamage - defense)); // 最低1ダメージ
            updatedPlayerData.hp = Math.max(0, playerData.hp - actualDamage); 
            feedback.player += `-${actualDamage}HP`; 
            
            const correctAnswerText = Array.isArray(currentProblem.answer) ? currentProblem.answer.join(" ÷ ") : currentProblem.answer.toString().replace(/\*/g, '×');
            updatedPlayerData.wrongProblems.push({ question: currentProblem.question, userAnswer: userAnswerValue, correctAnswer: correctAnswerText }); 
            
            setPlayerData(updatedPlayerData); 
            setBattleFeedback(feedback); 
            if (updatedPlayerData.hp <= 0) {
                setGameOver(true);
            } else {
                setShowExplanation(true); 
            }
        } 
        setTimeout(() => setBattleFeedback({ player: '', enemy: '' }), 1500); 
      };
      
      const checkStageConditions = (currentStats, isEnemyDown) => {
        if (!isEnemyDown) {
            setTimeout(nextProblem, 1000);
            return;
        }
        const { totalProblems, correctAnswers, consecutiveCorrect } = currentStats;
        let requiredAccuracy = 85, requiredConsecutive = 5, minProblems = 15;
        if (currentStage.boss) {
            if (currentStage.id === 14) { requiredAccuracy = 80; minProblems = 65; requiredConsecutive = 10; }
            else { requiredAccuracy = 90; minProblems = 20; requiredConsecutive = 5; }
        }
        if (totalProblems < minProblems) {
            setTimeout(nextProblem, 1000);
            return;
        }
        const accuracy = totalProblems > 0 ? (correctAnswers / totalProblems) * 100 : 0;
        if (accuracy >= requiredAccuracy && consecutiveCorrect >= requiredConsecutive) {
            setBattleResult('win');
            const item = generateRewardItem();
            const materials = generateMaterials(accuracy);
            if (item) { setTimeout(() => setItemGetNotification(item), 800); }
            const gotMaterials = [];
            if (materials.ironOre > 0) gotMaterials.push({ name: '🪨 鉄鉱石', count: materials.ironOre });
            if (materials.silverOre > 0) gotMaterials.push({ name: '💎 銀鉱石', count: materials.silverOre });
            if (materials.starFragment > 0) gotMaterials.push({ name: '⭐ 星の欠片', count: materials.starFragment });
            if (materials.perfectProof > 0) gotMaterials.push({ name: '🌟 完璧の証', count: materials.perfectProof });
            if (gotMaterials.length > 0) {
                const delay = item ? 4000 : 800; // アイテム通知の後に出す
                setTimeout(() => setMaterialGetNotification(gotMaterials), delay);
            }
            setPlayerData(prev => ({ ...prev, inventory: item ? [...prev.inventory, item] : prev.inventory, clearedStages: [...new Set([...prev.clearedStages, currentStage.id])], materials: { ironOre: prev.materials.ironOre + materials.ironOre, silverOre: prev.materials.silverOre + materials.silverOre, starFragment: prev.materials.starFragment + materials.starFragment, perfectProof: prev.materials.perfectProof + materials.perfectProof } }));
        } else {
            if (accuracy < requiredAccuracy || consecutiveCorrect < requiredConsecutive) {
                 setBattleResult('accuracy_failed'); // あるいは'consecutive_failed'など具体的に
            }
        }
      };

      const generateRewardItem = () => { const accuracy = (playerData.battleStats.correctAnswers / playerData.battleStats.totalProblems) * 100; const { reward: rewardType } = currentStage; if (!rewardType || ['special', 'ultimate'].includes(rewardType)) return null; let rank = 1; if (accuracy >= 95) rank = 3; else if (accuracy >= 90) rank = 2; return { type: rewardType, rank: rank, ...itemDatabase[rewardType][rank] }; };
      const generateMaterials = (accuracy) => { const m = { ironOre: 0, silverOre: 0, starFragment: 0, perfectProof: 0 }; if (accuracy === 100) m.perfectProof = 1; if (accuracy >= 95) m.starFragment = 1; if (accuracy >= 90) m.silverOre = 1; if (accuracy >= 85) m.ironOre = 1; return m; };
      const nextProblem = () => { 
        const acc = playerData.equipment.accessory; 
        if (acc) { 
            const mult = rankMultipliers[acc.rank]; 
            const rec = Math.round((acc.mp / 5) * mult); // MP回復量を装備のMP値と倍率で計算
            setPlayerData(prev => ({ ...prev, mp: Math.min(prev.maxMp, prev.mp + rec) })); 
        } 
        const nextIdx = (currentProblemIndex + 1) % battleProblems.length; 
        setCurrentProblem(battleProblems[nextIdx]); 
        setCurrentProblemIndex(nextIdx); 
      };
      const showHintFunction = () => { 
        const t = playerData.equipment.tool; 
        const mult = t ? rankMultipliers[t.rank] : 1; 
        const cost = t ? Math.max(0, 10 - Math.round(t.hint * mult)) : 10; 
        if (playerData.mp >= cost) { 
            setShowHint(true); 
            setPlayerData(prev => ({ ...prev, mp: prev.mp - cost, battleStats: { ...prev.battleStats, hintsUsed: prev.battleStats.hintsUsed + 1 } })); 
        } else {
            alert('MPが足りません！');
        }
      };
      
      const getMaxEquipmentRank = () => {
        const { level } = playerData;
        if (level >= 40) return 5;
        if (level >= 30) return 4;
        if (level >= 20) return 3;
        if (level >= 10) return 2;
        return 1;
      };

      const equipItem = (itemToEquip) => { 
        if (itemToEquip.rank > getMaxEquipmentRank()) { 
            alert(`レベルが足りません。このアイテムはレベル${10 * Math.floor((itemToEquip.rank-1)*1.5+1)}以上で装備できます。`); 
            return; 
        } 
        setPlayerData(prev => { 
          const newInv = [...prev.inventory]; 
          const curItem = prev.equipment[itemToEquip.type]; 
          if (curItem) newInv.push(curItem); // 既に装備しているアイテムをインベントリに戻す
          
          // インベントリからアイテムを削除 (既に装備しているものと名前・ランクが同じでも、別物として扱う)
          const itemIdx = newInv.findIndex(i => i.name === itemToEquip.name && i.rank === itemToEquip.rank); 
          if (itemIdx > -1) newInv.splice(itemIdx, 1); 

          return { ...prev, equipment: { ...prev.equipment, [itemToEquip.type]: itemToEquip }, inventory: newInv }; 
        }); 
        alert(`${itemToEquip.name}を装備しました。`); 
      };
      
      const unequipItem = (itemType) => {
        setPlayerData(prev => {
          const itemToUnequip = prev.equipment[itemType];
          if (!itemToUnequip) return prev;
          
          const newEquipment = { ...prev.equipment, [itemType]: null };
          const newInventory = [...prev.inventory, itemToUnequip];
          
          alert(`${itemToUnequip.name}を外しました。`);
          return { ...prev, equipment: newEquipment, inventory: newInventory };
        });
      };

      const forgeItem = (itemToForge) => {
        const recipe = forgeRecipes[itemToForge.type]?.[itemToForge.name];
        if (!recipe) { alert("これ以上強化できるレシピが見つかりません。"); return; }
        
        const requiredMaterials = recipe.materials;
        const currentMaterials = playerData.materials;
        let canForge = true;
        for (const mat in requiredMaterials) { 
            if (currentMaterials[mat] < requiredMaterials[mat]) { canForge = false; break; } 
        }
        
        if (!canForge) { 
            let missingMats = [];
            for (const mat in requiredMaterials) {
                if (currentMaterials[mat] < requiredMaterials[mat]) {
                    missingMats.push(`${mat}が${requiredMaterials[mat] - currentMaterials[mat]}個足りません`);
                }
            }
            alert(`素材が足りません！\n${missingMats.join('\n')}`); 
            return; 
        }
        
        if (!confirm(`${itemToForge.name} を強化しますか？`)) { return; }
        
        const newPlayerData = JSON.parse(JSON.stringify(playerData)); // ディープコピー
        const newMaterials = { ...newPlayerData.materials };
        for (const mat in requiredMaterials) { newMaterials[mat] -= requiredMaterials[mat]; }
        newPlayerData.materials = newMaterials;
        
        let wasEquipped = false;
        // 装備中のアイテムの場合、装備を解除
        if (newPlayerData.equipment[itemToForge.type]?.name === itemToForge.name && newPlayerData.equipment[itemToForge.type]?.rank === itemToForge.rank) {
          newPlayerData.equipment[itemToForge.type] = null;
          wasEquipped = true;
        } else {
          // インベントリ内のアイテムの場合、インベントリから削除
          const invIndex = newPlayerData.inventory.findIndex(i => i.name === itemToForge.name && i.rank === itemToForge.rank);
          if (invIndex > -1) { 
            newPlayerData.inventory.splice(invIndex, 1); 
          } else {
            alert("強化しようとしたアイテムが見つかりません。");
            return;
          }
        }
        
        const newItem = { ...recipe.result };
        // 強化後のアイテムを、元々装備していた場合は再装備、そうでなければインベントリに追加
        if (wasEquipped) { 
            newPlayerData.equipment[newItem.type] = newItem; 
        } else { 
            newPlayerData.inventory.push(newItem); 
        }
        
        setPlayerData(newPlayerData);
        setSelectedForgeItem(newItem); // 強化後に選択アイテムを更新してプレビューも更新
        alert(`${newItem.name} への強化に成功しました！`);
      };
      
      const getCharacterDisplay = () => { const { weapon, armor } = playerData.equipment; let c = '🧙‍♂️'; if (weapon && weapon.rank >= 3) c = '⚔️' + c; if (armor && armor.rank >= 3) c = '🛡️' + c; return c; };
      
      const renderContent = () => {
        switch (gameState) {
          case GAME_STATES.MENU: return <div className="min-h-screen bg-gradient-to-b from-blue-400 to-purple-600 flex flex-col items-center justify-center text-white p-4"> <div className="text-center"> <h1 className="text-5xl md:text-6xl font-bold mb-4">🏰 算数クエスト</h1> <h2 className="text-2xl md:text-3xl mb-8">～5年生の冒険～</h2> <div className="space-y-4"> <button onClick={() => changeGameState(GAME_STATES.STAGE_SELECT)} className="bg-green-500 hover:bg-green-600 px-8 py-4 rounded-lg text-xl font-bold block mx-auto w-64 transition-transform hover:scale-105">冒険を始める</button> <button onClick={loadGameFromFile} className="bg-orange-500 hover:bg-orange-600 px-8 py-4 rounded-lg text-xl font-bold block mx-auto w-64 transition-transform hover:scale-105">冒険を再開する</button> <button onClick={() => changeGameState(GAME_STATES.RULES)} className="bg-blue-500 hover:bg-blue-600 px-8 py-4 rounded-lg text-xl font-bold block mx-auto w-64 transition-transform hover:scale-105">ルール説明</button> </div> </div> </div>;
          case GAME_STATES.STAGE_SELECT: return <div className="min-h-screen bg-gradient-to-b from-green-400 to-blue-500 p-4 sm:p-8"> <div className="max-w-6xl mx-auto"> <div className="flex justify-between items-center mb-6"> <button onClick={() => changeGameState(GAME_STATES.MENU)} className="bg-gray-500 hover:bg-gray-600 px-4 py-2 rounded text-white shadow-md">🏠</button> <div className="flex flex-wrap gap-2 justify-end"> <button onClick={() => changeGameState(GAME_STATES.INVENTORY)} className="bg-purple-500 hover:bg-purple-600 px-4 py-2 rounded text-white flex items-center gap-2 shadow-md">📦 装備</button> <button onClick={() => changeGameState(GAME_STATES.FORGE)} className="bg-orange-500 hover:bg-orange-600 px-4 py-2 rounded text-white flex items-center gap-2 shadow-md">🔨 鍛冶屋</button> <button onClick={saveGameToFile} className="bg-green-500 hover:bg-green-600 px-4 py-2 rounded text-white flex items-center gap-2 shadow-md">💾 セーブ</button> </div> </div> <div className="bg-white/80 backdrop-blur-sm rounded-lg p-4 sm:p-6 mb-6 shadow-xl"> <div className="flex items-center gap-4 mb-4"><div className="text-4xl">{getCharacterDisplay()}</div><div className="flex-grow"><h3 className="font-bold text-lg">レベル {playerData.level}</h3>{playerData.level < MAX_LEVEL ? (<><div className="text-sm text-gray-600">EXP: {playerData.exp} / {getRequiredExp(playerData.level)}</div><div className="w-full bg-gray-200 rounded-full h-1.5 mt-1"><div className="bg-yellow-400 h-1.5 rounded-full" style={{width: `${(playerData.exp / getRequiredExp(playerData.level)) * 100}%`}}></div></div></>) : (<div className="text-sm font-bold text-yellow-500">EXP: MAX</div>)}</div><div className="ml-auto text-right flex-shrink-0"><div className="text-sm">HP: {playerData.hp}/{playerData.maxHp}</div><div className="text-sm">MP: {playerData.mp}/{playerData.maxMp}</div></div></div> <div className="grid grid-cols-2 sm:grid-cols-4 gap-2 text-sm text-gray-700"><div>🗡️ {playerData.equipment.weapon ? playerData.equipment.weapon.name : 'なし'}</div><div>🛡️ {playerData.equipment.armor ? playerData.equipment.armor.name : 'なし'}</div><div>💍 {playerData.equipment.accessory ? playerData.equipment.accessory.name : 'なし'}</div><div>🖊️ {playerData.equipment.tool ? playerData.equipment.tool.name : 'なし'}</div></div> </div> <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"> {stages.map(stage => { const isCleared = playerData.clearedStages.includes(stage.id); const isAvailable = canEnterStage(stage); return (<div key={stage.id} className={`bg-white rounded-lg p-4 border-2 transition-all duration-300 ${isCleared ? 'border-green-500 bg-green-50' : stage.boss ? 'border-red-500' : 'border-gray-300'} ${!isAvailable ? 'opacity-50 cursor-not-allowed' : 'hover:shadow-lg hover:-translate-y-1 cursor-pointer'}`} onClick={() => isAvailable && startBattle(stage)}> <div className="text-center"><div className="text-3xl mb-2">{stage.boss ? '🏰' : '🗺️'}{isCleared && '✅'}</div><h3 className="font-bold text-sm mb-1">{stage.id}. {stage.name}</h3><p className="text-xs text-gray-600 mb-2 h-8">{stage.topic}</p><p className="text-xs font-bold text-red-600">{stage.enemy}</p>{!isAvailable && !isCleared && (<p className="text-xs text-red-500 mt-1">進行条件を満たしていません</p>)}</div> </div>); })} </div> </div> </div>;
          case GAME_STATES.BATTLE: { 
            const stageConditions = (() => { if (!currentStage) return { minProblems: 15, requiredConsecutive: 5 }; let minProblems = 15, requiredConsecutive = 5; if (currentStage.boss) { if (currentStage.id === 14) { minProblems = 65; requiredConsecutive = 10; } else { minProblems = 20; requiredConsecutive = 5; } } return { minProblems, requiredConsecutive }; })();
            const remainingProblems = Math.max(0, stageConditions.minProblems - playerData.battleStats.totalProblems);
            if (gameOver) return (<div className="min-h-screen bg-gradient-to-b from-gray-800 to-black flex items-center justify-center p-4"><div className="bg-white rounded-lg p-8 max-w-md w-full mx-4 text-center shadow-2xl"><h2 className="text-4xl font-bold text-red-600 mb-4">💀 GAME OVER 💀</h2><p className="text-gray-700 mb-6">残念！力が及ばなかった...HPを回復して再挑戦しよう。</p>{playerData.wrongProblems.length > 0 && (<div className="bg-red-50 p-4 rounded mb-4 text-left max-h-40 overflow-y-auto"><h3 className="font-bold mb-2">間違えた問題:</h3><div className="text-sm space-y-2">{playerData.wrongProblems.map((p, i) => { const isFrac = p.correctAnswer.includes('/'); const [num, den] = isFrac ? p.correctAnswer.split('/') : [null, null]; return (<div key={i} className="py-1"><p className="text-gray-600">{p.question}</p><p className="text-red-600">あなたの答え: {p.userAnswer}</p><p className="text-green-600 inline-flex items-center gap-1">正解: {isFrac ? <FractionDisplay numerator={num} denominator={den} /> : p.correctAnswer}</p></div>) })}</div></div>)}<div className="flex gap-4 mt-6"><button onClick={() => changeGameState(GAME_STATES.STAGE_SELECT)} className="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-3 rounded-lg font-bold">マップに戻る</button><button onClick={() => startBattle(currentStage)} className="flex-1 bg-red-500 hover:bg-red-600 text-white py-3 rounded-lg font-bold flex items-center justify-center gap-2">🔄 再挑戦</button></div></div></div>); 
            if (battleResult) { const isWin = battleResult === 'win'; return (<div className={`min-h-screen flex items-center justify-center p-4 ${isWin ? 'bg-gradient-to-b from-yellow-300 to-orange-400' : 'bg-gradient-to-b from-blue-300 to-indigo-400'}`}><div className="bg-white rounded-lg p-8 max-w-md w-full mx-4 text-center shadow-2xl"><h2 className={`text-4xl font-bold mb-4 ${isWin ? 'text-orange-500' : 'text-blue-500'}`}>{isWin ? '🎉 ステージクリア！ 🎉' : '💪 もう一息！ 💪'}</h2><p className="text-gray-700 mb-6">{isWin ? 'おめでとう！見事に敵を打ち破った！' : '正答率または連続正解数が足りなかった！'}</p>{isWin && (<div className="bg-green-50 p-4 rounded mb-4 text-left"><h3 className="font-bold mb-2">ステージ成績:</h3><p>正答率: {playerData.battleStats.totalProblems > 0 ? Math.round((playerData.battleStats.correctAnswers / playerData.battleStats.totalProblems) * 100) : 0}%</p><p>解答数: {playerData.battleStats.totalProblems}問</p></div>)}<div className="flex gap-4 mt-6"><button onClick={() => changeGameState(GAME_STATES.STAGE_SELECT)} className="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-3 rounded-lg font-bold">マップに戻る</button>{!isWin && <button onClick={() => startBattle(currentStage)} className="flex-1 bg-red-500 hover:bg-red-600 text-white py-3 rounded-lg font-bold flex items-center justify-center gap-2">🔄 再挑戦</button>}</div></div></div>); } 
            
            const tool = playerData.equipment.tool; const mult = tool ? rankMultipliers[tool.rank] : 1; const cost = tool ? Math.max(0, 10 - Math.round(t.hint * mult)) : 10; 
            
            const renderBattleUI = () => {
                return (
                    <>
                    <div className="mb-4 text-2xl">
                        { currentProblem.type === 'fraction' ? 
                            <div className="flex items-center justify-center gap-2">
                               <div className="fraction-input-container">
                                  <input type="text" inputmode="numeric" readOnly value={fractionTop} onFocus={() => setActiveInput('fractionTop')} className={`numerator-input p-2 text-center text-lg focus:outline-none ${activeInput === 'fractionTop' ? 'active-input-field' : ''}`} placeholder="分子" />
                                  <input type="text" inputmode="numeric" readOnly value={fractionBottom} onFocus={() => setActiveInput('fractionBottom')} className={`denominator-input p-2 text-center text-lg focus:outline-none ${activeInput === 'fractionBottom' ? 'active-input-field' : ''}`} placeholder="分母" />
                               </div>
                            </div>
                        : currentProblem.type === 'division_form' ? 
                            <div className="flex items-center justify-center gap-2">
                                <input type="text" inputmode="numeric" readOnly value={divisionNumerator} onFocus={() => setActiveInput('divisionNumerator')} className={`w-24 p-3 border rounded text-center text-lg focus:outline-none ${activeInput === 'divisionNumerator' ? 'active-input-field' : ''}`} placeholder="割られる数" />
                                <div className="text-2xl font-bold">÷</div>
                                <input type="text" inputmode="numeric" readOnly value={divisionDenominator} onFocus={() => setActiveInput('divisionDenominator')} className={`w-24 p-3 border rounded text-center text-lg focus:outline-none ${activeInput === 'divisionDenominator' ? 'active-input-field' : ''}`} placeholder="割る数" />
                            </div>
                        : (currentProblem.type === 'integer' || currentProblem.type === 'decimal') ? 
                            <div className="flex items-center justify-center">
                                {currentProblem.isApproximation && <span className="text-2xl mr-2 font-bold">約</span>}
                                <input type="text" inputmode="decimal" readOnly value={userAnswer} onFocus={() => setActiveInput('answer')} className={`w-full p-3 border rounded text-lg focus:outline-none ${activeInput === 'answer' ? 'active-input-field' : ''}`} placeholder="答えを入力" />
                            </div>
                        : // type: 'equation'
                             <input type="text" readOnly value={userAnswer} onFocus={() => setActiveInput('answer')} className={`w-full p-3 border rounded text-lg focus:outline-none ${activeInput === 'answer' ? 'active-input-field' : ''}`} placeholder="式を入力" />
                        }
                    </div>
                    
                    <div className="grid grid-cols-5 gap-2 text-lg mt-4">
                        {['7', '8', '9'].map(k => <button key={k} onClick={() => handlePadInput(k)} className="p-3 rounded-lg font-bold text-white bg-gray-700 hover:bg-gray-800 transition-transform hover:scale-105">{k}</button>)}
                        {currentProblem.type === 'equation' ? <button onClick={() => handlePadInput('〇')} className="p-3 rounded-lg font-bold text-white bg-blue-500 hover:bg-blue-600">〇</button> : <div/>}
                        <button onClick={() => handlePadInput('⌫')} className="p-3 rounded-lg font-bold text-white bg-red-500 hover:bg-red-600">⌫</button>
                        
                        {['4', '5', '6'].map(k => <button key={k} onClick={() => handlePadInput(k)} className="p-3 rounded-lg font-bold text-white bg-gray-700 hover:bg-gray-800 transition-transform hover:scale-105">{k}</button>)}
                        {currentProblem.type === 'equation' ? <button onClick={() => handlePadInput('□')} className="p-3 rounded-lg font-bold text-white bg-blue-500 hover:bg-blue-600">□</button> : <div/>}
                        <button onClick={() => handlePadInput('C')} className="p-3 rounded-lg font-bold text-white bg-red-500 hover:bg-red-600">C</button>
                        
                        {['1', '2', '3'].map(k => <button key={k} onClick={() => handlePadInput(k)} className="p-3 rounded-lg font-bold text-white bg-gray-700 hover:bg-gray-800 transition-transform hover:scale-105">{k}</button>)}
                        {currentProblem.type === 'equation' ? <button onClick={() => handlePadInput('=')} className="p-3 rounded-lg font-bold text-white bg-orange-500 hover:bg-orange-600">=</button> : <div/>}
                        {currentProblem.type === 'equation' ? <button onClick={() => handlePadInput('×')} className="p-3 rounded-lg font-bold text-white bg-orange-500 hover:bg-orange-600">×</button> : <div/>}

                        <button onClick={() => handlePadInput('0')} className="p-3 rounded-lg font-bold text-white bg-gray-700 hover:bg-gray-800 col-span-2">0</button>
                        <button onClick={() => handlePadInput('.')} className="p-3 rounded-lg font-bold text-white bg-gray-700 hover:bg-gray-800">.</button>
                        {currentProblem.type === 'equation' ? <button onClick={() => handlePadInput('+')} className="p-3 rounded-lg font-bold text-white bg-orange-500 hover:bg-orange-600">+</button> : <div/>}
                        {currentProblem.type === 'equation' ? <button onClick={() => handlePadInput('-')} className="p-3 rounded-lg font-bold text-white bg-orange-500 hover:bg-orange-600">-</button> : <div/>}
                    </div>

                    <div className="flex gap-4 flex-wrap mt-6">
                        <button onClick={checkAnswer} className="bg-green-500 hover:bg-green-600 text-white px-6 py-3 rounded-lg font-bold transition-transform hover:scale-105" disabled={showExplanation}>答える</button>
                        {currentProblem.hint && !showHint && (<button onClick={showHintFunction} className="bg-yellow-500 hover:bg-yellow-600 text-white px-6 py-3 rounded-lg font-bold" disabled={playerData.mp < cost || showExplanation}>ヒント (MP-{cost})</button>)}
                    </div>
                    </>
                );
            };

            return (<div className="min-h-screen bg-gradient-to-b from-red-500 to-orange-600 p-2 sm:p-4"><div className="max-w-4xl mx-auto"><div className="flex justify-between items-center mb-4"><button onClick={() => changeGameState(GAME_STATES.STAGE_SELECT)} className="bg-gray-700 hover:bg-gray-800 px-4 py-2 rounded text-white shadow-md">🏠</button><h2 className="text-xl sm:text-2xl font-bold text-white text-center">{currentStage?.name}</h2><button onClick={() => changeGameState(GAME_STATES.RULES)} className="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded text-white shadow-md">ℹ️</button></div><div className="grid grid-cols-2 gap-4 mb-4"><div className="bg-white/90 backdrop-blur-sm rounded-lg p-3 relative"><div className="text-center"><div className="text-4xl mb-2">{getCharacterDisplay()}</div><h3 className="font-bold">プレイヤー</h3><div className="mt-2 text-sm"><div>HP: {playerData.hp}/{playerData.maxHp}</div><div className="w-full bg-gray-200 rounded-full h-2.5"><div className="bg-green-500 h-2.5 rounded-full transition-all duration-500" style={{width: `${(playerData.hp / playerData.maxHp) * 100}%`}}></div></div><div className="mt-1">MP: {playerData.mp}/{playerData.maxMp}</div><div className="w-full bg-gray-200 rounded-full h-2.5"><div className="bg-blue-500 h-2.5 rounded-full transition-all duration-500" style={{width: `${(playerData.mp / playerData.maxMp) * 100}%`}}></div></div></div></div>{battleFeedback.player && (<div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-2xl font-bold text-red-500 drop-shadow-lg animate-ping-once">{battleFeedback.player}</div>)}</div><div className="bg-white/90 backdrop-blur-sm rounded-lg p-3 relative"><div className="text-center"><div className="text-4xl mb-2">{enemyDefeated ? '😵' : '👹'}</div><h3 className="font-bold">{currentStage?.enemy}</h3><div className="mt-2 text-sm"><div>HP: {enemyHp}/{maxEnemyHp}</div><div className="w-full bg-gray-200 rounded-full h-2.5"><div className="bg-red-500 h-2.5 rounded-full transition-all duration-500" style={{width: `${(enemyHp / maxEnemyHp) * 100}%`}}></div></div></div></div>{battleFeedback.enemy && !enemyDefeated && (<div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-4xl font-bold text-red-500 drop-shadow-lg animate-ping-once">{battleFeedback.enemy}</div>)}</div></div>
            {enemyDefeated && ( <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-4 mb-4 rounded shadow-md"> <p className="font-bold">敵を撃破！ステージクリアまであと少し！</p> <div className="mt-2 text-sm font-semibold space-y-1"> {remainingProblems > 0 ? ( <p>・最低でもあと <strong>{remainingProblems}</strong> 問解こう！</p> ) : ( <p className="text-green-600">・問題数はクリア！</p> )} <p>・最後に <strong>{stageConditions.requiredConsecutive}</strong> 問の連続正解が必要！ (現在: {playerData.battleStats.consecutiveCorrect}問)</p> </div> </div> )}
            {currentProblem && (<div className="bg-white/95 backdrop-blur-sm rounded-lg p-4 sm:p-6">
                <div className="flex justify-between items-center mb-4"><h3 className="font-bold text-lg">問題 {currentProblemIndex + 1}</h3><div className="text-sm text-gray-600">{playerData.battleStats.correctAnswers}/{playerData.battleStats.totalProblems}問正解 (連続{playerData.battleStats.consecutiveCorrect})</div></div>
                <p className="text-gray-800 mb-6 text-lg whitespace-pre-wrap">{currentProblem.question}</p>
                {renderBattleUI()}
                {showHint && <div className="mt-4 p-4 bg-yellow-100 rounded-lg"><h4 className="font-bold">ヒント:</h4><p>{currentProblem.hint}</p></div>}
                {showExplanation && (<div className="mt-4 p-4 bg-red-100 rounded-lg"><h4 className="font-bold">解説:</h4><p>{currentProblem.explanation}</p><button onClick={nextProblem} className="mt-4 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-bold">次の問題へ</button></div>)}
            </div>)}
            </div></div>); 
          }
          case GAME_STATES.RULES: {
            const returnState = currentStage ? GAME_STATES.BATTLE : GAME_STATES.MENU;
            return (
              <div className="min-h-screen bg-gray-800 text-white p-4 sm:p-8">
                <div className="max-w-3xl mx-auto">
                  <h1 className="text-3xl font-bold mb-6 text-center text-yellow-300">📜 ルール説明</h1>
                  <div className="bg-gray-700 p-6 rounded-lg space-y-4">
                    <h2 className="text-xl font-bold text-yellow-400">戦闘の基本</h2>
                    <p>・算数の問題を解いて敵を攻撃します。正解すると敵にダメージを与え、経験値(EXP)を獲得できます。</p>
                    <p>・間違えると敵から攻撃を受けてHPが減ります。HPが0になるとゲームオーバーです。</p>
                    <h2 className="text-xl font-bold text-yellow-400">レベルアップ</h2>
                    <p>・経験値が一定量たまるとレベルアップし、HPやMPの最大値が上昇します。</p>
                    <p>・レベルが上がると、より強力なアイテムを装備できるようになります。</p>
                    <h2 className="text-xl font-bold text-yellow-400">ステージクリア条件</h2>
                    <p>・敵のHPを0にした後も、ステージ毎に決められた問題数を解く必要があります。</p>
                    <p>・最終的に、高い正答率と、指定された数の連続正解を達成するとステージクリアとなります。</p>
                    <h2 className="text-xl font-bold text-yellow-400">ヒントとMP</h2>
                    <p>・MPを消費して問題のヒントを見ることができます。MPが足りないとヒントは見れません。</p>
                    <p>・MPは問題を5問連続で正解したり、特定のアクセサリーを装備することで回復します。</p>
                    <h2 className="text-xl font-bold text-yellow-400">装備と鍛冶</h2>
                    <p>・ステージクリアで手に入れたアイテムは「装備」画面で装備できます。装備すると冒険が有利になります。</p>
                    <p>・「鍛冶屋」では、戦闘で手に入れた素材を使ってアイテムを強化できます。</p>
                  </div>
                  <div className="text-center mt-8">
                    <button onClick={() => changeGameState(returnState)} className="bg-blue-500 hover:bg-blue-600 px-8 py-3 rounded-lg text-lg font-bold">戻る</button>
                  </div>
                </div>
              </div>
            );
          }
          case GAME_STATES.INVENTORY: {
            const renderItemCard = (item, isEquipped = false) => (
              <div key={`${item.name}-${item.rank}`} className="bg-gray-700 p-4 rounded-lg border border-gray-600 flex flex-col justify-between">
                <div>
                  <h3 className="text-lg font-bold text-yellow-400">{item.name} <span className="text-sm text-white">{'★'.repeat(item.rank)}</span></h3>
                  <p className="text-sm text-gray-300 mt-1">{item.effect}</p>
                </div>
                <div className="mt-3">
                  {isEquipped ? (
                    <button onClick={() => unequipItem(item.type)} className="bg-red-500 hover:bg-red-600 px-3 py-1 rounded text-sm font-bold w-full">外す</button>
                  ) : (
                    <button onClick={() => equipItem(item)} className="bg-green-500 hover:bg-green-600 px-3 py-1 rounded text-sm font-bold w-full disabled:bg-gray-500" disabled={item.rank > getMaxEquipmentRank()}>
                      {item.rank > getMaxEquipmentRank() ? `Lv.${10 * Math.floor((item.rank-1)*1.5+1)}以上` : '装備する'}
                    </button>
                  )}
                </div>
              </div>
            );
            return (
              <div className="min-h-screen bg-gray-800 text-white p-4 sm:p-8">
                <div className="max-w-4xl mx-auto">
                  <div className="flex justify-between items-center mb-6">
                    <h1 className="text-3xl font-bold">📦 装備・所持品</h1>
                    <button onClick={() => changeGameState(GAME_STATES.STAGE_SELECT)} className="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">マップに戻る</button>
                  </div>
                  <h2 className="text-2xl font-bold mb-4 border-b-2 border-yellow-400 pb-2">現在の装備</h2>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-8">
                    {Object.entries(playerData.equipment).map(([type, item]) => (
                      <div key={type} className="bg-gray-900 p-4 rounded-lg">
                        <h3 className="text-lg capitalize font-semibold mb-2">{type === 'weapon' ? '🗡️ 武器' : type === 'armor' ? '🛡️ 防具' : type === 'accessory' ? '💍 装飾品' : '🖊️ 道具'}:</h3>
                        {item ? renderItemCard(item, true) : <p className="text-gray-400 p-4">なし</p>}
                      </div>
                    ))}
                  </div>
                  <h2 className="text-2xl font-bold mb-4 border-b-2 border-yellow-400 pb-2">所持品</h2>
                  {playerData.inventory.length > 0 ? (
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                      {playerData.inventory.map(item => renderItemCard(item))}
                    </div>
                  ) : ( <p className="text-gray-400 mt-4">所持品はありません。</p> )}
                </div>
              </div>
            );
          }
          case GAME_STATES.FORGE: {
            const forgeableItems = [...Object.values(playerData.equipment), ...playerData.inventory]
              .filter(Boolean)
              .filter(item => item && forgeRecipes[item.type]?.[item.name]);
            return (
              <div className="min-h-screen bg-gray-800 text-white p-4 sm:p-8">
                <div className="max-w-5xl mx-auto">
                  <div className="flex justify-between items-center mb-6">
                    <h1 className="text-3xl font-bold">🔨 鍛冶屋</h1>
                    <button onClick={() => changeGameState(GAME_STATES.STAGE_SELECT)} className="bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded">マップに戻る</button>
                  </div>
                  <div className="bg-gray-700 p-4 rounded-lg mb-6 flex justify-around flex-wrap gap-4 text-sm sm:text-base">
                    <h3 className="font-bold w-full text-center mb-2 text-lg">所持素材</h3>
                    <span>🪨 鉄鉱石: {playerData.materials.ironOre}</span>
                    <span>💎 銀鉱石: {playerData.materials.silverOre}</span>
                    <span>⭐ 星の欠片: {playerData.materials.starFragment}</span>
                    <span>🌟 完璧の証: {playerData.materials.perfectProof}</span>
                  </div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-8">
                    <div>
                      <h2 className="text-2xl font-bold mb-4">強化可能なアイテム</h2>
                      <div className="space-y-3 max-h-[60vh] overflow-y-auto pr-2 bg-gray-900 p-2 rounded-lg">
                        {forgeableItems.length > 0 ? (
                          forgeableItems.map(item => (
                            <button key={`${item.name}-${item.rank}`} onClick={() => setSelectedForgeItem(item)} className={`w-full text-left p-3 rounded-lg transition-colors ${selectedForgeItem?.name === item.name && selectedForgeItem?.rank === item.rank ? 'bg-blue-600 ring-2 ring-blue-300' : 'bg-gray-700 hover:bg-gray-600'}`}>
                              <span className="font-bold">{item.name}</span> {'★'.repeat(item.rank)}
                            </button>
                          ))
                        ) : ( <p className="text-gray-400 p-4">強化できるアイテムがありません。</p> )}
                      </div>
                    </div>
                    <div className="bg-gray-900 p-6 rounded-lg">
                      <h2 className="text-2xl font-bold mb-4 text-center">強化プレビュー</h2>
                      {selectedForgeItem && forgeRecipes[selectedForgeItem.type]?.[selectedForgeItem.name] ? (() => {
                          const recipe = forgeRecipes[selectedForgeItem.type][selectedForgeItem.name];
                          const canForge = Object.entries(recipe.materials).every(([mat, count]) => playerData.materials[mat] >= count);
                          const matNames = { ironOre: '鉄鉱石', silverOre: '銀鉱石', starFragment: '星の欠片', perfectProof: '完璧の証'};
                          return (
                            <div className="text-center">
                              <p className="mb-2">選択中:</p>
                              <h3 className="text-xl font-bold text-yellow-400">{selectedForgeItem.name} {'★'.repeat(selectedForgeItem.rank)}</h3>
                              <div className="my-4 text-2xl animate-bounce">↓</div>
                              <h3 className="text-xl font-bold text-green-400">{recipe.result.name} {'★'.repeat(recipe.result.rank)}</h3>
                              <div className="mt-6 text-left bg-gray-800 p-4 rounded">
                                <h4 className="font-bold mb-2">必要な素材:</h4>
                                <ul className="list-disc list-inside">
                                  {Object.entries(recipe.materials).map(([mat, count]) => {
                                    const hasEnough = playerData.materials[mat] >= count;
                                    return <li key={mat} className={hasEnough ? 'text-green-400' : 'text-red-400'}>{matNames[mat]}: {count} (所持: {playerData.materials[mat]})</li>;
                                  })}
                                </ul>
                              </div>
                              <button onClick={() => forgeItem(selectedForgeItem)} disabled={!canForge} className="mt-6 w-full py-3 rounded-lg font-bold text-lg bg-orange-500 hover:bg-orange-600 disabled:bg-gray-500 disabled:cursor-not-allowed">強化する</button>
                            </div>
                          );
                      })() : ( <p className="text-gray-400 text-center pt-10">左のリストから強化したいアイテムを選択してください。</p> )}
                    </div>
                  </div>
                </div>
              </div>
            );
          }
          default: return null;
        }
      };

      return (
        <div className="font-sans bg-gray-900 w-full h-full overflow-auto">
          <input type="file" ref={fileInputRef} onChange={handleFileSelect} className="hidden" accept=".json,application/json" />
          {renderContent()}
          {itemGetNotification && ( <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 cursor-pointer" onClick={() => setItemGetNotification(null)}> <div className="animate-item-get-pop text-center"> <div className="bg-gradient-to-b from-gray-700 to-gray-900 border-4 border-yellow-400 rounded-xl p-8 shadow-2xl relative overflow-hidden shine-effect"> <p className="text-white text-xl mb-4 drop-shadow-md">新しいアイテムを手に入れた！</p> <h3 className="text-yellow-300 text-3xl font-bold mb-2 drop-shadow-lg">{itemGetNotification.name}</h3> <p className="text-yellow-400 text-2xl drop-shadow-md">{'★'.repeat(itemGetNotification.rank)}</p> </div> <p className="text-white mt-4 text-sm">クリックで閉じる</p> </div> </div> )}
          {materialGetNotification && ( <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 cursor-pointer" onClick={() => setMaterialGetNotification(null)}> <div className="animate-item-get-pop text-center"> <div className="bg-gradient-to-b from-gray-700 to-gray-900 border-4 border-green-400 rounded-xl p-8 shadow-2xl relative overflow-hidden shine-effect"> <p className="text-white text-xl mb-4 drop-shadow-md">素材を手に入れた！</p> <div className="space-y-2"> {materialGetNotification.map((mat, index) => ( <h3 key={index} className="text-green-300 text-2xl font-bold drop-shadow-lg">{mat.name} x {mat.count}</h3> ))} </div> </div> <p className="text-white mt-4 text-sm">クリックで閉じる</p> </div> </div> )}
          {levelUpNotification && (
            <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 cursor-pointer" onClick={() => setLevelUpNotification(null)}>
              <div className="animate-item-get-pop text-center">
                <div className="bg-gradient-to-br from-blue-500 to-purple-700 border-4 border-yellow-300 rounded-xl p-8 shadow-2xl relative overflow-hidden shine-effect">
                  <p className="text-white text-3xl font-bold mb-4 drop-shadow-md animate-bounce">🎉 LEVEL UP! 🎉</p>
                  <h3 className="text-yellow-200 text-4xl font-bold mb-6 drop-shadow-lg">レベルが {levelUpNotification.level} に上がった！</h3>
                  <div className="text-white text-lg space-y-2 bg-black/30 p-4 rounded-lg">
                    <p>最大HP: {levelUpNotification.maxHp - levelUpNotification.hpUp} → <span className="font-bold text-green-300">{levelUpNotification.maxHp} (+{levelUpNotification.hpUp})</span></p>
                    <p>最大MP: {levelUpNotification.maxMp - levelUpNotification.mpUp} → <span className="font-bold text-blue-300">{levelUpNotification.maxMp} (+{levelUpNotification.mpUp})</span></p>
                  </div>
                </div>
                <p className="text-white mt-4 text-sm">クリックで閉じる</p>
              </div>
            </div>
          )}
        </div>
      );
    };

    const container = document.getElementById('root');
    const root = ReactDOM.createRoot(container);
    root.render(<MathRPGApp />);
  </script>
</body>
</html>